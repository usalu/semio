import cytoscape from 'cytoscape'
import { Matrix4, Quaternion, Vector3 } from 'three'
import {
    Point as TPoint,
    Vector as TVector,
    Plane as TPlane,
    Design,
    DesignInput,
    Piece as TPiece,
    PieceInput,
    Port
} from './semio.d'

export const TOLERANCE = 1e-5

// Generated by: https://the-guild.dev/graphql/codegen with "Schema Types"
// export type Maybe<T> = T | null
// export type InputMaybe<T> = Maybe<T>
// export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] }
// export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> }
// export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> }
// export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never }
// export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never }
// /** All built-in and custom scalars, mapped to their actual values */
// export type Scalars = {
//     ID: { input: string; output: string; }
//     String: { input: string; output: string; }
//     Boolean: { input: boolean; output: boolean; }
//     Int: { input: number; output: number; }
//     Float: { input: number; output: number; }
//     /**
//      * The `DateTime` scalar type represents a DateTime
//      * value as specified by
//      * [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
//      */
//     DateTime: { input: any; output: any; }
// }

// export type Query = {
//     __typename?: 'Query'
//     loadLocalKit?: Maybe<LoadLocalKitResponse>
//     designToSceneFromLocalKit?: Maybe<DesignToSceneFromLocalKitResponse>
// }

// export type QueryLoadLocalKitArgs = {
//     directory: Scalars['String']['input']
// }

// export type QueryDesignToSceneFromLocalKitArgs = {
//     directory: Scalars['String']['input']
//     designIdInput: DesignIdInput
// }

// export type LoadLocalKitResponse = {
//     __typename?: 'LoadLocalKitResponse'
//     kit?: Maybe<Kit>
//     error?: Maybe<LoadLocalKitError>
// }

// /** üóÉÔ∏è A kit is a collection of types and designs. */
// export type Kit = {
//     __typename?: 'Kit'
//     name: Scalars['String']['output']
//     description: Scalars['String']['output']
//     icon: Scalars['String']['output']
//     createdAt: Scalars['DateTime']['output']
//     lastUpdateAt: Scalars['DateTime']['output']
//     url: Scalars['String']['output']
//     homepage: Scalars['String']['output']
//     types: Array<Type>
//     designs: Array<Design>
// }

// /** üß© A type is a reusable element that can be connected with other types over ports. */
// export type Type = {
//     __typename?: 'Type'
//     name: Scalars['String']['output']
//     description: Scalars['String']['output']
//     icon: Scalars['String']['output']
//     variant: Scalars['String']['output']
//     unit: Scalars['String']['output']
//     createdAt: Scalars['DateTime']['output']
//     lastUpdateAt: Scalars['DateTime']['output']
//     kit?: Maybe<Kit>
//     representations: Array<Representation>
//     ports: Array<Port>
//     qualities: Array<Quality>
//     pieces: Array<Piece>
// }

// /** üíæ A representation is a link to a resource that describes a type for a certain level of detail and tags. */
// export type Representation = {
//     __typename?: 'Representation'
//     url: Scalars['String']['output']
//     lod: Scalars['String']['output']
//     type?: Maybe<Type>
//     tags: Array<Scalars['String']['output']>
// }

// /** üîå A port is a conceptual connection point (with a direction) of a type. */
// export type Port = {
//     __typename?: 'Port'
//     type?: Maybe<Type>
//     locators: Array<Locator>
//     connecteds: Array<Connection>
//     connectings: Array<Connection>
//     id: Scalars['String']['output']
//     point: Point
//     direction: Vector
//     plane: Plane
// }

// /** üó∫Ô∏è A locator is meta-data for grouping ports. */
// export type Locator = {
//     __typename?: 'Locator'
//     group: Scalars['String']['output']
//     subgroup: Scalars['String']['output']
//     port?: Maybe<Port>
// }

// /** üñáÔ∏è A bidirectional connection between two pieces of a design. */
// export type Connection = {
//     __typename?: 'Connection'
//     gap: Scalars['Float']['output']
//     rotation: Scalars['Float']['output']
//     design?: Maybe<Design>
//     connected: Side
//     connecting: Side
// }

// /** üèôÔ∏è A design is a collection of pieces that are connected. */
// export type Design = {
//     __typename?: 'Design'
//     name: Scalars['String']['output']
//     description: Scalars['String']['output']
//     icon: Scalars['String']['output']
//     variant: Scalars['String']['output']
//     unit: Scalars['String']['output']
//     createdAt: Scalars['DateTime']['output']
//     lastUpdateAt: Scalars['DateTime']['output']
//     kit?: Maybe<Kit>
//     pieces: Array<Piece>
//     connections: Array<Connection>
//     qualities: Array<Quality>
// }

// /** ‚≠ï A piece is a 3d-instance of a type in a design. */
// export type Piece = {
//     __typename?: 'Piece'
//     type?: Maybe<Type>
//     design?: Maybe<Design>
//     connectings: Array<Connection>
//     connecteds: Array<Connection>
//     id: Scalars['String']['output']
//     root?: Maybe<PieceRoot>
//     diagram: PieceDiagram
// }

// /** üå± The root indesign of a piece. */
// export type PieceRoot = {
//     __typename?: 'PieceRoot'
//     plane: Plane
// }

// /** ‚ó≥ A plane is an origin (point) and an orientation (x-axis and y-axis). */
// export type Plane = {
//     __typename?: 'Plane'
//     origin: Point
//     xAxis: Vector
//     yAxis: Vector
// }

// /** ‚úñÔ∏è A 3d-point (xyz) of floating point numbers. */
// export type Point = {
//     __typename?: 'Point'
//     x: Scalars['Float']['output']
//     y: Scalars['Float']['output']
//     z: Scalars['Float']['output']
// }

// /** ‚û°Ô∏è A 3d-vector (xyz) of floating point numbers. */
// export type Vector = {
//     __typename?: 'Vector'
//     x: Scalars['Float']['output']
//     y: Scalars['Float']['output']
//     z: Scalars['Float']['output']
// }

// /** ‚úèÔ∏è The diagram indesign of a piece. */
// export type PieceDiagram = {
//     __typename?: 'PieceDiagram'
//     point: DiagramPoint
// }

// /** üì∫ A 2d-point (xy) of integers in screen plane. */
// export type DiagramPoint = {
//     __typename?: 'DiagramPoint'
//     x: Scalars['Int']['output']
//     y: Scalars['Int']['output']
// }

// /** üìè A quality is meta-data for decision making. */
// export type Quality = {
//     __typename?: 'Quality'
//     name: Scalars['String']['output']
//     value: Scalars['String']['output']
//     unit: Scalars['String']['output']
//     definition: Scalars['String']['output']
//     type?: Maybe<Type>
//     design?: Maybe<Design>
// }

// /** üß± A side of a piece in a connection. */
// export type Side = {
//     __typename?: 'Side'
//     piece: SidePiece
// }

// /** ‚≠ï The piece indesign of a side. A piece is identified by an id (emtpy=default)). */
// export type SidePiece = {
//     __typename?: 'SidePiece'
//     id: Scalars['String']['output']
//     type: SidePieceType
// }

// /** üß© The type indesign of a piece of a side. */
// export type SidePieceType = {
//     __typename?: 'SidePieceType'
//     port?: Maybe<Port>
// }

// export enum LoadLocalKitError {
//     DirectoryDoesNotExist = 'DIRECTORY_DOES_NOT_EXIST',
//     DirectoryIsNotADirectory = 'DIRECTORY_IS_NOT_A_DIRECTORY',
//     DirectoryHasNoKit = 'DIRECTORY_HAS_NO_KIT',
//     NoPermissionToReadKit = 'NO_PERMISSION_TO_READ_KIT'
// }

// export type DesignToSceneFromLocalKitResponse = {
//     __typename?: 'DesignToSceneFromLocalKitResponse'
//     scene?: Maybe<Scene>
//     error?: Maybe<DesignToSceneFromLocalKitResponseError>
// }

// /** üåÜ A scene is a collection of objects. */
// export type Scene = {
//     __typename?: 'Scene'
//     objects: Array<Maybe<Object>>
//     design?: Maybe<Design>
// }

// /** üóø An object is a piece with a plane and a parent object (unless the piece is a root). */
// export type Object = {
//     __typename?: 'Object'
//     plane: Plane
//     piece?: Maybe<Piece>
//     parent?: Maybe<Object>
// }

// export type DesignToSceneFromLocalKitResponseError = {
//     __typename?: 'DesignToSceneFromLocalKitResponseError'
//     code: DesignToSceneFromLocalKitResponseErrorCode
//     message?: Maybe<Scalars['String']['output']>
// }

// export enum DesignToSceneFromLocalKitResponseErrorCode {
//     DirectoryDoesNotExist = 'DIRECTORY_DOES_NOT_EXIST',
//     DirectoryIsNotADirectory = 'DIRECTORY_IS_NOT_A_DIRECTORY',
//     DirectoryHasNoKit = 'DIRECTORY_HAS_NO_KIT',
//     NoPermissionToReadKit = 'NO_PERMISSION_TO_READ_KIT',
//     DesignDoesNotExist = 'DESIGN_DOES_NOT_EXIST'
// }

// /** üèôÔ∏è A design is identified by a name and optional variant. */
// export type DesignIdInput = {
//     name: Scalars['String']['input']
//     variant?: InputMaybe<Scalars['String']['input']>
// }

// export type Mutation = {
//     __typename?: 'Mutation'
//     createLocalKit?: Maybe<CreateLocalKitMutation>
//     updateLocalKitMetadata?: Maybe<UpdateLocalKitMetadataMutation>
//     deleteLocalKit?: Maybe<DeleteLocalKitMutation>
//     addTypeToLocalKit?: Maybe<AddTypeToLocalKitMutation>
//     removeTypeFromLocalKit?: Maybe<RemoveTypeFromLocalKitMutation>
//     addDesignToLocalKit?: Maybe<AddDesignToLocalKitMutation>
//     removeDesignFromLocalKit?: Maybe<RemoveDesignFromLocalKitMutation>
// }

// export type MutationCreateLocalKitArgs = {
//     directory: Scalars['String']['input']
//     kitInput: KitInput
// }

// export type MutationUpdateLocalKitMetadataArgs = {
//     directory: Scalars['String']['input']
//     kitMetadataInput: KitMetadataInput
// }

// export type MutationDeleteLocalKitArgs = {
//     directory: Scalars['String']['input']
// }

// export type MutationAddTypeToLocalKitArgs = {
//     directory: Scalars['String']['input']
//     typeInput: TypeInput
// }

// export type MutationRemoveTypeFromLocalKitArgs = {
//     directory: Scalars['String']['input']
//     typeId: TypeIdInput
// }

// export type MutationAddDesignToLocalKitArgs = {
//     directory: Scalars['String']['input']
//     designInput: DesignInput
// }

// export type MutationRemoveDesignFromLocalKitArgs = {
//     directory: Scalars['String']['input']
//     designId: DesignIdInput
// }

// export type CreateLocalKitMutation = {
//     __typename?: 'CreateLocalKitMutation'
//     kit?: Maybe<Kit>
//     error?: Maybe<CreateLocalKitError>
// }

// export type CreateLocalKitError = {
//     __typename?: 'CreateLocalKitError'
//     code: CreateLocalKitErrorCode
//     message?: Maybe<Scalars['String']['output']>
// }

// export enum CreateLocalKitErrorCode {
//     DirectoryIsNotADirectory = 'DIRECTORY_IS_NOT_A_DIRECTORY',
//     DirectoryAlreadyContainsAKit = 'DIRECTORY_ALREADY_CONTAINS_A_KIT',
//     NoPermissionToCreateDirectory = 'NO_PERMISSION_TO_CREATE_DIRECTORY',
//     NoPermissionToCreateKit = 'NO_PERMISSION_TO_CREATE_KIT',
//     KitInputIsInvalid = 'KIT_INPUT_IS_INVALID'
// }

// /** üóÉÔ∏è A kit is a collection of types and designs. */
// export type KitInput = {
//     name: Scalars['String']['input']
//     description?: InputMaybe<Scalars['String']['input']>
//     icon?: InputMaybe<Scalars['String']['input']>
//     url?: InputMaybe<Scalars['String']['input']>
//     homepage?: InputMaybe<Scalars['String']['input']>
//     types?: InputMaybe<Array<TypeInput>>
//     designs?: InputMaybe<Array<DesignInput>>
// }

// /** üß© A type is a reusable element that can be connected with other types over ports. */
// export type TypeInput = {
//     name: Scalars['String']['input']
//     description?: InputMaybe<Scalars['String']['input']>
//     icon?: InputMaybe<Scalars['String']['input']>
//     variant?: InputMaybe<Scalars['String']['input']>
//     unit: Scalars['String']['input']
//     representations: Array<RepresentationInput>
//     ports: Array<PortInput>
//     qualities?: InputMaybe<Array<QualityInput>>
// }

// /** üíæ A representation is a link to a resource that describes a type for a certain level of detail and tags. */
// export type RepresentationInput = {
//     url: Scalars['String']['input']
//     lod?: InputMaybe<Scalars['String']['input']>
//     tags?: InputMaybe<Array<Scalars['String']['input']>>
// }

// /** üîå A port is a conceptual connection point (with a direction) of a type. */
// export type PortInput = {
//     id?: InputMaybe<Scalars['String']['input']>
//     point: PointInput
//     direction: VectorInput
//     locators?: InputMaybe<Array<LocatorInput>>
// }

// /** ‚úñÔ∏è A 3d-point (xyz) of floating point numbers. */
// export type PointInput = {
//     x?: InputMaybe<Scalars['Float']['input']>
//     y?: InputMaybe<Scalars['Float']['input']>
//     z?: InputMaybe<Scalars['Float']['input']>
// }

// /** ‚û°Ô∏è A 3d-vector (xyz) of floating point numbers. */
// export type VectorInput = {
//     x?: InputMaybe<Scalars['Float']['input']>
//     y?: InputMaybe<Scalars['Float']['input']>
//     z?: InputMaybe<Scalars['Float']['input']>
// }

// /** üó∫Ô∏è A locator is meta-data for grouping ports. */
// export type LocatorInput = {
//     group: Scalars['String']['input']
//     subgroup?: InputMaybe<Scalars['String']['input']>
// }

// /** üìè A quality is meta-data for decision making. */
// export type QualityInput = {
//     name: Scalars['String']['input']
//     value?: InputMaybe<Scalars['String']['input']>
//     unit?: InputMaybe<Scalars['String']['input']>
//     definition?: InputMaybe<Scalars['String']['input']>
// }

// /** üèôÔ∏è A design is a collection of pieces that are connected. */
// export type DesignInput = {
//     name: Scalars['String']['input']
//     description?: InputMaybe<Scalars['String']['input']>
//     icon?: InputMaybe<Scalars['String']['input']>
//     variant?: InputMaybe<Scalars['String']['input']>
//     unit: Scalars['String']['input']
//     pieces: Array<PieceInput>
//     connections: Array<ConnectionInput>
//     qualities?: InputMaybe<Array<QualityInput>>
// }

// /** ‚≠ï A piece is a 3d-instance of a type in a design. */
// export type PieceInput = {
//     id: Scalars['String']['input']
//     type: TypeIdInput
//     root?: InputMaybe<PieceRootInput>
//     diagram: PieceDiagramInput
// }

// /** üß© A type is identified by a name and variant (empty=default). */
// export type TypeIdInput = {
//     name: Scalars['String']['input']
//     variant?: InputMaybe<Scalars['String']['input']>
// }

// /** üå± The root indesign of a piece. */
// export type PieceRootInput = {
//     plane: PlaneInput
// }

// /** ‚ó≥ A plane is an origin (point) and an orientation (x-axis and y-axis). */
// export type PlaneInput = {
//     origin: PointInput
//     xAxis: VectorInput
//     yAxis: VectorInput
// }

// /** ‚úèÔ∏è The diagram indesign of a piece. */
// export type PieceDiagramInput = {
//     point: DiagramPointInput
// }

// /** üì∫ A 2d-point (xy) of integers in screen plane. */
// export type DiagramPointInput = {
//     x?: InputMaybe<Scalars['Int']['input']>
//     y?: InputMaybe<Scalars['Int']['input']>
// }

// /** üñáÔ∏è A bidirectional connection between two pieces of a design. */
// export type ConnectionInput = {
//     connecting: SideInput
//     connected: SideInput
//     gap?: InputMaybe<Scalars['Float']['input']>
//     rotation?: InputMaybe<Scalars['Float']['input']>
// }

// /** üß± A side of a piece in a connection. */
// export type SideInput = {
//     piece: SidePieceInput
// }

// /** ‚≠ï The piece indesign of a side. A piece is identified by an id (emtpy=default)). */
// export type SidePieceInput = {
//     id: Scalars['String']['input']
//     type?: InputMaybe<SidePieceTypeInput>
// }

// /** üß© The type indesign of a piece of a side. */
// export type SidePieceTypeInput = {
//     port?: InputMaybe<PortIdInput>
// }

// /** üîå A port is identified by an id (emtpy=default)). */
// export type PortIdInput = {
//     id?: InputMaybe<Scalars['String']['input']>
// }

// export type UpdateLocalKitMetadataMutation = {
//     __typename?: 'UpdateLocalKitMetadataMutation'
//     kit?: Maybe<Kit>
//     error?: Maybe<UpdateLocalKitMetadataError>
// }

// export type UpdateLocalKitMetadataError = {
//     __typename?: 'UpdateLocalKitMetadataError'
//     code: UpdateLocalKitMetadataErrorCode
//     message?: Maybe<Scalars['String']['output']>
// }

// export enum UpdateLocalKitMetadataErrorCode {
//     DirectoryDoesNotExist = 'DIRECTORY_DOES_NOT_EXIST',
//     DirectoryIsNotADirectory = 'DIRECTORY_IS_NOT_A_DIRECTORY',
//     DirectoryHasNoKit = 'DIRECTORY_HAS_NO_KIT',
//     NoPermissionToUpdateKit = 'NO_PERMISSION_TO_UPDATE_KIT',
//     KitMetadataIsInvalid = 'KIT_METADATA_IS_INVALID'
// }

// /** üóÉÔ∏è Meta-data of a kit. */
// export type KitMetadataInput = {
//     name?: InputMaybe<Scalars['String']['input']>
//     description?: InputMaybe<Scalars['String']['input']>
//     icon?: InputMaybe<Scalars['String']['input']>
//     url?: InputMaybe<Scalars['String']['input']>
//     homepage?: InputMaybe<Scalars['String']['input']>
// }

// export type DeleteLocalKitMutation = {
//     __typename?: 'DeleteLocalKitMutation'
//     error?: Maybe<DeleteLocalKitError>
// }

// export enum DeleteLocalKitError {
//     DirectoryDoesNotExist = 'DIRECTORY_DOES_NOT_EXIST',
//     DirectoryHasNoKit = 'DIRECTORY_HAS_NO_KIT',
//     NoPermissionToDeleteKit = 'NO_PERMISSION_TO_DELETE_KIT'
// }

// export type AddTypeToLocalKitMutation = {
//     __typename?: 'AddTypeToLocalKitMutation'
//     type?: Maybe<Type>
//     error?: Maybe<AddTypeToLocalKitError>
// }

// export type AddTypeToLocalKitError = {
//     __typename?: 'AddTypeToLocalKitError'
//     code: AddTypeToLocalKitErrorCode
//     message?: Maybe<Scalars['String']['output']>
// }

// export enum AddTypeToLocalKitErrorCode {
//     DirectoryDoesNotExist = 'DIRECTORY_DOES_NOT_EXIST',
//     DirectoryIsNotADirectory = 'DIRECTORY_IS_NOT_A_DIRECTORY',
//     DirectoryHasNoKit = 'DIRECTORY_HAS_NO_KIT',
//     NoPermissionToModifyKit = 'NO_PERMISSION_TO_MODIFY_KIT',
//     TypeInputIsInvalid = 'TYPE_INPUT_IS_INVALID'
// }

// export type RemoveTypeFromLocalKitMutation = {
//     __typename?: 'RemoveTypeFromLocalKitMutation'
//     error?: Maybe<RemoveTypeFromLocalKitError>
// }

// export type RemoveTypeFromLocalKitError = {
//     __typename?: 'RemoveTypeFromLocalKitError'
//     code: RemoveTypeFromLocalKitErrorCode
//     message?: Maybe<Scalars['String']['output']>
// }

// export enum RemoveTypeFromLocalKitErrorCode {
//     DirectoryDoesNotExist = 'DIRECTORY_DOES_NOT_EXIST',
//     DirectoryIsNotADirectory = 'DIRECTORY_IS_NOT_A_DIRECTORY',
//     DirectoryHasNoKit = 'DIRECTORY_HAS_NO_KIT',
//     NoPermissionToModifyKit = 'NO_PERMISSION_TO_MODIFY_KIT',
//     TypeDoesNotExist = 'TYPE_DOES_NOT_EXIST',
//     DesignDependsOnType = 'DESIGN_DEPENDS_ON_TYPE'
// }

// export type AddDesignToLocalKitMutation = {
//     __typename?: 'AddDesignToLocalKitMutation'
//     design?: Maybe<Design>
//     error?: Maybe<AddDesignToLocalKitError>
// }

// export type AddDesignToLocalKitError = {
//     __typename?: 'AddDesignToLocalKitError'
//     code: AddDesignToLocalKitErrorCode
//     message?: Maybe<Scalars['String']['output']>
// }

// export enum AddDesignToLocalKitErrorCode {
//     DirectoryDoesNotExist = 'DIRECTORY_DOES_NOT_EXIST',
//     DirectoryIsNotADirectory = 'DIRECTORY_IS_NOT_A_DIRECTORY',
//     DirectoryHasNoKit = 'DIRECTORY_HAS_NO_KIT',
//     NoPermissionToModifyKit = 'NO_PERMISSION_TO_MODIFY_KIT',
//     DesignInputIsInvalid = 'DESIGN_INPUT_IS_INVALID'
// }

// export type RemoveDesignFromLocalKitMutation = {
//     __typename?: 'RemoveDesignFromLocalKitMutation'
//     error?: Maybe<RemoveDesignFromLocalKitError>
// }

// export type RemoveDesignFromLocalKitError = {
//     __typename?: 'RemoveDesignFromLocalKitError'
//     code: RemoveDesignFromLocalKitErrorCode
//     message?: Maybe<Scalars['String']['output']>
// }

// export enum RemoveDesignFromLocalKitErrorCode {
//     DirectoryDoesNotExist = 'DIRECTORY_DOES_NOT_EXIST',
//     DirectoryIsNotADirectory = 'DIRECTORY_IS_NOT_A_DIRECTORY',
//     DirectoryHasNoKit = 'DIRECTORY_HAS_NO_KIT',
//     NoPermissionToModifyKit = 'NO_PERMISSION_TO_MODIFY_KIT',
//     DesignDoesNotExist = 'DESIGN_DOES_NOT_EXIST'
// }

export enum Plane {
    SEMIO = 'SEMIO',
    THREE = 'THREE'
}

export const radians = (degrees: number): number => {
    return degrees * (Math.PI / 180)
}

export const degrees = (radians: number): number => {
    return radians * (180 / Math.PI)
}

export class Point extends Vector3 {
    constructor(x: number = 0, y: number = 0, z: number = 0) {
        super(x, y, z)
    }

    [n: number]: number

    *[Symbol.iterator](): Iterator<number> {
        yield this.x
        yield this.y
        yield this.z
    }

    get 0(): number {
        return this.x
    }
    get 1(): number {
        return this.y
    }
    get 2(): number {
        return this.z
    }

    isCloseTo(other: Point | Vector | number, tol: number = TOLERANCE): boolean {
        if (typeof other === 'number') {
            return (
                Math.abs(this.x - other) < tol &&
                Math.abs(this.y - other) < tol &&
                Math.abs(this.z - other) < tol
            )
        } else if (other instanceof Vector) {
            return this.isCloseTo(other.toPoint(), tol)
        } else {
            return (
                Math.abs(this.x - other.x) < tol &&
                Math.abs(this.y - other.y) < tol &&
                Math.abs(this.z - other.z) < tol
            )
        }
    }

    toVector(): Vector {
        return new Vector(this.x, this.y, this.z)
    }

    static fromVector(vector: Vector): Point {
        return new Point(vector.x, vector.y, vector.z)
    }

    static parse(object: Point | TPoint | string | null | undefined): Point {
        if (object === undefined || object === null) {
            return new Point()
        }
        if (object instanceof Point) {
            return object
        }
        if (typeof object === 'string') {
            const { x, y, z } = JSON.parse(object)
            return new Point(x, y, z)
        }
        return new Point(object.x, object.y, object.z)
    }
}

export class Vector extends Vector3 {
    constructor(x: number = 0, y: number = 0, z: number = 0) {
        super(x, y, z)
    }

    [n: number]: number

    *[Symbol.iterator](): Iterator<number> {
        yield this.x
        yield this.y
        yield this.z
    }

    get 0(): number {
        return this.x
    }
    get 1(): number {
        return this.y
    }
    get 2(): number {
        return this.z
    }

    sqrt(): Vector {
        return new Vector(Math.sqrt(this.x), Math.sqrt(this.y), Math.sqrt(this.z))
    }

    sign(): Vector {
        return new Vector(Math.sign(this.x), Math.sign(this.y), Math.sign(this.z))
    }

    isCloseTo(other: Vector | Point | number, tol: number = TOLERANCE): boolean {
        if (typeof other === 'number') {
            return (
                Math.abs(this.x - other) < tol &&
                Math.abs(this.y - other) < tol &&
                Math.abs(this.z - other) < tol
            )
        } else if (other instanceof Point) {
            return this.isCloseTo(other.toVector(), tol)
        } else {
            return (
                Math.abs(this.x - other.x) < tol &&
                Math.abs(this.y - other.y) < tol &&
                Math.abs(this.z - other.z) < tol
            )
        }
    }

    isZero(tol: number = TOLERANCE): boolean {
        return this.isCloseTo(new Vector(), tol)
    }

    toPoint(): Point {
        return new Point(this.x, this.y, this.z)
    }

    toTransform(): Transform {
        return Transform.fromTranslation(this)
    }

    static X(): Vector {
        return new Vector(1, 0, 0)
    }

    static Y(): Vector {
        return new Vector(0, 1, 0)
    }

    static Z(): Vector {
        return new Vector(0, 0, 1)
    }

    static parse(object: Vector | TVector | string | null | undefined): Vector {
        if (object === undefined || object === null) {
            return new Vector()
        }
        if (object instanceof Vector) {
            return object
        }
        if (typeof object === 'string') {
            const { x, y, z } = JSON.parse(object)
            return new Vector(x, y, z)
        }
        return new Vector(object.x, object.y, object.z)
    }
}

export class Plane {
    origin: Point
    xAxis: Vector
    yAxis: Vector

    constructor(origin?: Point, xAxis?: Vector, yAxis?: Vector) {
        this.origin = origin ?? new Point()
        this.xAxis = xAxis ?? Vector.X()
        this.yAxis = yAxis ?? Vector.Y()
        if (this.xAxis.length() - 1 > TOLERANCE) {
            throw new Error('The x-axis must be normalized.')
        }
        if (this.yAxis.length() - 1 > TOLERANCE) {
            throw new Error('The y-axis must be normalized.')
        }
        if (Math.abs(this.xAxis.dot(this.yAxis)) > TOLERANCE) {
            throw new Error('The x-axis and y-axis must be orthogonal.')
        }
    }

    get zAxis(): Vector {
        return new Vector().crossVectors(this.xAxis, this.yAxis)
    }

    isCloseTo(other: Plane, tol: number = TOLERANCE): boolean {
        return (
            this.origin.isCloseTo(other.origin, tol) &&
            this.xAxis.isCloseTo(other.xAxis, tol) &&
            this.yAxis.isCloseTo(other.yAxis, tol)
        )
    }

    transform(transform: Transform): Plane {
        return transform.transformPlane(this)
    }

    toTransform(): Transform {
        return Transform.fromPlane(this)
    }

    toThree(): Plane {
        return this.transform(semioToThreeRotation())
    }

    toSemio(): Plane {
        return this.transform(threeToSemioRotation())
    }

    static XY(): Plane {
        return new Plane(new Point(), Vector.X(), Vector.Y())
    }

    static fromYAxis(yAxis: Vector, theta: number = 0, origin?: Point): Plane {
        if (yAxis.length() - 1 > TOLERANCE) {
            throw new Error('The yAxis must be normalized.')
        }
        const orientation = Transform.fromDirections(Vector.Y(), yAxis)
        const rotation = Transform.fromAngle(yAxis, theta)
        const xAxis = Vector.X().applyMatrix4(rotation.multiply(orientation))
        return new Plane(origin ?? new Point(), xAxis, yAxis)
    }

    static parse(object?: Plane | TPlane | string | null | undefined): Plane {
        if (object === undefined || object === null) {
            return new Plane()
        }
        if (object instanceof Plane) {
            return object
        }
        if (typeof object === 'string') {
            const { origin, xAxis, yAxis } = JSON.parse(object)
            return new Plane(Point.parse(origin), Vector.parse(xAxis), Vector.parse(yAxis))
        }
        return new Plane(
            Point.parse(object.origin),
            Vector.parse(object.xAxis),
            Vector.parse(object.yAxis)
        )
    }
}

export class Rotation {
    axis: Vector
    angle: number

    constructor(axis?: Vector, angle: number = 0) {
        this.axis = axis ?? Vector.Z()
        this.angle = angle
    }

    toTransform(): Transform {
        return Transform.fromRotation(this)
    }

    toJSON(): object | null {
        return this.angle === 0
            ? null
            : {
                  axis: this.axis,
                  angle: this.angle
              }
    }
}

export class Transform extends Matrix4 {
    constructor() {
        super()
    }
    get rotation(): Rotation {
        //https://github.com/dfki-ric/pytransform3d/blob/c45e817c4a7960108afe9f5259542c8376c0e89a/pytransform3d/rotations/_conversions.py#L1719
        const rotationMatrix = new Matrix4()
        rotationMatrix.extractRotation(this)
        const trace =
            rotationMatrix.elements[0] + rotationMatrix.elements[5] + rotationMatrix.elements[10]
        const cosAngle = (trace - 1) / 2
        const angle = Math.acos(Math.min(Math.max(-1, cosAngle), 1))
        if (angle === 0) return new Rotation()
        const axisUnnormalized = new Vector(
            rotationMatrix[6] - rotationMatrix[9],
            rotationMatrix[8] - rotationMatrix[2],
            rotationMatrix[1] - rotationMatrix[4]
        )
        let axis: Vector
        if (Math.abs(angle - Math.PI) < 1e-4) {
            const clampedDiagonal = new Vector(
                rotationMatrix[0],
                rotationMatrix[5],
                rotationMatrix[10]
            ).clampScalar(-1, 1)
            const eeTDiag = clampedDiagonal.clone().addScalar(1).multiplyScalar(0.5)
            const signs = axisUnnormalized.clone().sign()
            const unitizedSigns = new Vector(signs.x || 1, signs.y || 1, signs.z || 1)
            axis = eeTDiag.sqrt().multiply(unitizedSigns)
        } else {
            axis = axisUnnormalized
        }
        const normalizedAxis = axis.normalize()
        return new Rotation(normalizedAxis, degrees(angle))
    }

    get translation(): Vector {
        const translation = new Vector()
        this.decompose(translation, new Quaternion(), new Vector())
        return translation
    }

    clone(): Transform {
        return new Transform().copy(this)
    }

    after(before: Transform): Transform {
        return new Transform().multiplyMatrices(before, this)
    }

    transformPoint(point: Point): Point {
        const transformedPoint = point.clone().applyMatrix4(this)
        return new Point(transformedPoint.x, transformedPoint.y, transformedPoint.z)
    }

    transformVector(vector: Vector): Vector {
        const transformedVector = vector.clone().applyMatrix4(this)
        return new Vector(transformedVector.x, transformedVector.y, transformedVector.z)
    }

    transformPlane(plane: Plane): Plane {
        const planeTransform = Transform.fromPlane(plane)
        const planeTransformed = planeTransform.after(this.clone())
        return planeTransformed.toPlane()
    }

    transform(geometry: Point | Vector | Plane): Point | Vector | Plane {
        if (geometry instanceof Point) {
            return this.transformPoint(geometry)
        } else if (geometry instanceof Vector) {
            return this.transformVector(geometry)
        } else if (geometry instanceof Plane) {
            return this.transformPlane(geometry)
        } else {
            throw new Error('Not implemented')
        }
    }

    static fromTranslation(vector: Vector): Transform {
        return new Transform().makeTranslation(vector.x, vector.y, vector.z)
    }

    static fromRotation(rotation: Rotation): Transform {
        return new Transform().makeRotationAxis(rotation.axis, radians(rotation.angle))
    }

    static fromPlane(plane: Plane): Transform {
        return new Transform()
            .makeBasis(plane.xAxis, plane.yAxis, plane.zAxis)
            .setPosition(plane.origin)
    }

    static fromAngle(axis: Vector, angle: number): Transform {
        return new Transform().makeRotationAxis(axis, radians(angle))
    }

    static fromDirections(startDirection: Vector, endDirection: Vector): Transform {
        if (startDirection.isCloseTo(endDirection)) {
            return new Transform()
        }
        const axisAngle = new Vector3().crossVectors(startDirection, endDirection)
        return new Transform().makeRotationAxis(
            axisAngle.normalize(),
            startDirection.angleTo(endDirection)
        )
    }

    toPlane(): Plane {
        const origin = new Point(this[12], this[13], this[14])
        const xAxis = new Vector(this[0], this[1], this[2])
        const yAxis = new Vector(this[4], this[5], this[6])
        return new Plane(origin, xAxis, yAxis)
    }

    toJSON(): object {
        return {
            rotation: this.rotation,
            translation: this.translation.isZero ? null : this.translation
        }
    }

    static parse(object: Transform | string | null | undefined): Transform {
        if (object === undefined || object === null) {
            return new Transform()
        }
        if (object instanceof Transform) {
            return object
        }
        if (typeof object === 'string') {
            const { rotation, translation } = JSON.parse(object)
            return new Transform()
                .makeRotationAxis(Vector.parse(rotation.axis), radians(rotation.angle))
                .setPosition(Vector.parse(translation))
        }
        return new Transform()
            .makeRotationAxis(Vector.parse(object.rotation.axis), radians(object.rotation.angle))
            .setPosition(Vector.parse(object.translation))
    }
}

export const semioToThreeRotation = (): Transform => {
    return new Transform().set(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1)
}

export const threeToSemioRotation = (): Transform => {
    return new Transform().set(1, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1)
}

class Hierarchy {
    piece: Piece | PieceInput
    transform: Transform
    children: Hierarchy[]

    constructor(
        piece: Piece | PieceInput,
        transform?: Transform | null | undefined,
        children?: Hierarchy[] | null | undefined
    ) {
        this.piece = piece
        this.transform = transform ?? new Transform()
        this.children = children ?? []
    }
}

export default Hierarchy

// Reference in Python:
// def designToHierarchies(design: Design) -> List[Hierarchy]:
//     nodes = list((piece.localId, {"piece": piece}) for piece in design.pieces)
//     edges = (
//         (
//             connection.connecting.piece.id,
//             connection.connected.piece.id,
//             {"connection": connection},
//         )
//         for connection in design.connections
//     )
//     graph = Graph()
//     graph.add_nodes_from(nodes)
//     graph.add_edges_from(edges)
//     hierarchies = []
//     for componentGenerator in connected_components(graph):
//         component = graph.subgraph(componentGenerator)
//         try:
//             root = [
//                 node for node in component.nodes() if graph.nodes[node]["piece"].root
//             ][0]
//         except IndexError:
//             root = next(iter(component.nodes))
//         rootHierarchy = Hierarchy(
//             piece=graph.nodes[root]["piece"],
//             transform=Transform(),
//             children=[],
//         )
//         component.nodes[root]["hierarchy"] = rootHierarchy
//         for parent, child in bfs_tree(component, source=root).edges():
//             connection = component[parent][child]["connection"]
//             connectedIsParent = connection.connected.piece.id == parent
//             parentPort = connection.connected.piece.type.port if connectedIsParent else connection.connecting.piece.type.port
//             childPort = connection.connecting.piece.type.port if connectedIsParent else connection.connected.piece.type.port
//             orient = Transform.fromDirections(childPort.direction.revert(), parentPort.direction)
//             rotation = orient
//             if connection.rotation != 0.0:
//                 rotate = Transform.fromAngle(parentPort.direction, connection.rotation)
//                 rotation = rotate.after(orient)
//             centerConnecting = childPort.point.toVector().revert().toTransform()
//             moveToConnected = parentPort.point.toVector().toTransform()
//             transform = rotation.after(centerConnecting)
//             if connection.gap != 0.0:
//                 gap = parentPort.direction.amplify(connection.gap).toTransform()
//                 transform = gap.after(transform)
//             transform = moveToConnected.after(transform)
//             hierarchy = Hierarchy(
//                 piece=component.nodes[child]["piece"],
//                 transform=transform,
//                 children=[],
//             )
//             component.nodes[child]["hierarchy"] = hierarchy
//             component.nodes[parent]["hierarchy"].children.append(hierarchy)
//         hierarchies.append(rootHierarchy)
//     return hierarchies
export const designToHierarchies = (
    design: Design | DesignInput,
    ports: Map<string, Map<string, Map<string, Port>>> // typeName -> typeVariant -> portId -> port
): Hierarchy[] => {
    if (design.pieces.length === 0) return []
    const cy = cytoscape({
        elements: {
            nodes: design.pieces.map((piece) => ({
                data: { id: piece.id, label: piece.id }
            })),
            edges: design.connections.map((connection) => ({
                data: {
                    id: `${connection.connecting.piece.id}-${connection.connected.piece.id}`,
                    source: connection.connected.piece.id,
                    target: connection.connecting.piece.id
                }
            }))
        }
    })
    const hierarchies: Hierarchy[] = []
    const components = cy.elements().components()
    components.forEach((component) => {
        const roots = component
            .nodes()
            .filter((node) => design.pieces.find((p) => p.id === node.id()).root)
        const root = roots.length === 0 ? component.nodes()[0] : roots[0]
        const rootPiece = design.pieces.find((p) => p.id === root.id())
        const rootHierarchy = new Hierarchy(rootPiece)
        hierarchies.push(rootHierarchy)
        const pieceIdToHierarchy: { [key: string]: Hierarchy } = {}
        pieceIdToHierarchy[rootHierarchy.piece.id] = rootHierarchy
        cy.elements().bfs({
            root,
            visit: (v, e, u, i, depth) => {
                if (depth === 0) return
                const parentId = u.id()
                const childId = v.id()
                const connection = design.connections.find(
                    (connection) =>
                        connection.connected.piece.id === e.source().id() &&
                        connection.connecting.piece.id === e.target().id()
                )
                const connectedIsParent = connection.connected.piece.id === parentId
                const parentPiece = design.pieces.find((p) => p.id === parentId)
                const childPiece = design.pieces.find((p) => p.id === childId)
                const parentPortId = connectedIsParent
                    ? connection.connected.piece?.type.port?.id
                    : connection.connecting.piece?.type.port?.id
                const childPortId = connectedIsParent
                    ? connection.connecting.piece?.type.port?.id
                    : connection.connected.piece?.type.port?.id
                const parentPort = ports
                    .get(parentPiece.type.name)
                    ?.get(parentPiece.type.variant ?? '')
                    ?.get(parentPortId ?? '')
                const childPort = ports
                    .get(childPiece.type.name)
                    ?.get(childPiece.type.variant ?? '')
                    ?.get(childPortId ?? '')
                const parentDirection = Vector.parse(parentPort.direction)
                const childDirection = Vector.parse(childPort.direction)
                const parentPoint = Point.parse(parentPort.point)
                const childPoint = Point.parse(childPort.point)
                const orient = Transform.fromDirections(childDirection.negate(), parentDirection)
                let rotation = orient
                if (connection.rotation !== 0) {
                    const rotate = Transform.fromAngle(parentDirection, connection.rotation)
                    rotation = rotate.after(orient)
                }
                const centerChild = childPoint.toVector().negate().toTransform()
                const moveToParent = parentPoint.toVector().toTransform()
                let transform = new Transform()
                transform = rotation.after(centerChild)
                if (connection.gap !== 0) {
                    const gap = parentDirection.clone().multiplyScalar(connection.gap).toTransform()
                    transform = gap.after(transform)
                }
                transform = moveToParent.after(transform)
                const hierarchy = new Hierarchy(childPiece, transform)
                // console.log(hierarchy, transform.toPlane(), rotation, centerChild, moveToParent)
                pieceIdToHierarchy[childPiece.id] = hierarchy
                pieceIdToHierarchy[parentPiece.id].children.push(hierarchy)
            }
        })
        console.log(JSON.stringify(rootHierarchy))
    })
    return hierarchies
}
