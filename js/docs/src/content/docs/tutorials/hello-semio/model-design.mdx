---
title: ğŸ§© Create Design
description: Shows how to snap the pieces into a model.
sidebar:
  order: 3
---

This section shows how to **turn your brick molds** â€” the **Types** and **Variants** youâ€™ve defined â€” into real, usable building blocks ğŸ§±

As explained in *[Think in Semio]*, a Type is just a **blueprint**. It defines how a brick should look and behave â€” but itâ€™s not a brick yet ğŸ“

To actually build a design, you need to create **Pieces** â€” the bricks made from your molds, ready to place, connect, and assemble ğŸ§©

---

## ğŸ”– Place Your Bricks (Model Pieces â€“ Pcs)

Now itâ€™s time to **turn your molds into actual bricks** â€” called **Pieces** ğŸ§©  
These are the elements youâ€™ll place, move, and connect in your design ğŸ¯

![ğŸ“¤ sketch drawing](/sketch-drawing-piece.png)

When you create a Piece, you're telling Semio:  
*"Take this specific mold (Type + Variant) and make a real, usable brick from it."* ğŸ§±

---

Each **Piece** automatically includes everything from its mold:

- **Geometry (Representation)** â€” the shape defined by the Variantâ€™s geometry file ğŸ§±  
- **Ports** â€” the snap points and their directions from the Type âš“  
- **Semantic Data** â€” the Type name, Variant identity, and design role ğŸ§   
- **Metadata** â€” any extra info like function, material, or tags ğŸ“„  

In short: a Piece is a fully formed brick, based on the rules and shape you defined earlier ğŸ”

---

### ğŸ†” Name the Pieces

Each Piece needs a unique name â€” its ID â€” so Semio can ğŸ§­ track, ğŸ”— reference, and ğŸ§© connect it later on.
Think of it as giving your brick a personal label ğŸ·ï¸

In this example, we name the Pieces based on the Semio logo â€” using both **color** and **position** for clarity ğŸ¨

- ğŸŸ¨ `Yel` â†’ yellow piece on the left  
- ğŸ”´ `Red-T` â†’ red piece at the top  
- ğŸ”´ `Red-R` â†’ red piece on the right  
- ğŸ”µ `Blu-T` â†’ blue piece at the top  
- ğŸ”µ `Blu-B` â†’ blue piece at the bottom  

As always in Semio, naming is flexible ğŸ”¤  
But a clear and consistent system makes your design easier to understand, build, and share ğŸ§ 

> ğŸ’¡ Itâ€™s like putting a sticker on each LEGO brick so you always know which one goes where ğŸ§±

---

### ğŸ§¬ Link to the Mold

To model a Piece, Semio needs to know **which mold itâ€™s made from** ğŸ”—  
That means linking it to a specific **Type** and **Variant**:

- ğŸ·ï¸ **Type name** â†’ e.g. `'Profile'`  
- ğŸ”¢ **Variant number** â†’ e.g. `2`, `4`, or `5`  

ğŸ‘‰ Without this reference, the Piece has no identity â€” it wonâ€™t know what shape to take or how to connect âš ï¸

---

##### ğŸ“ Example from the Sketch

In our example, the final **Design** includes five Pieces, built from **three different Variants**:

- 2Ã— Variant `2`  
- 1Ã— Variant `4`  
- 2Ã— Variant `5`  

We'll give each of these Pieces a **unique ID**, like so:

| Variant | Piece IDs            |
| ------- | -------------------- |
| `4`     | `Yel`                |
| `5`     | `Red-T`, `Red-R`     |
| `2`     | `Blu-T`, `Blu-B`     |

These are the **actual bricks** you'll be placing into your model ğŸ§±

---

##### ğŸ› ï¸ In Grasshopper

Now that you understand what a Piece is, let's learn how to **cast them** using the Semio plugin in **Grasshopper** ğŸ¦—

As shown in the image, youâ€™ll use the **Model Piece `Pce` component** and provide three key inputs:

1. ğŸ†” **Piece IDs** â†’ Unique names for each brick (e.g. `Yel`, `Blu-B`)  
2. ğŸ”¢ **Variant Numbers** â†’ Tell Semio which Variant of the mold to use (e.g. `2`, `5`)  
3. ğŸ·ï¸ **Type Name** â†’ The shared name of the mold (e.g. `'Profile'`)

Each row becomes a new **Piece**, named by its ID â€” like `Pce(Yel)` or `Pce(Red-R)` â€”  
each one inherits geometry, ports, and semantic logic from its **Type** and **Variant** ğŸ”

ğŸ§± Letâ€™s start by modeling the first two Pieces from the sketch

![Model Piece Component](/model-piece-10Alpha.png)

Once all five Pieces are created, your model will look like this:

![Model Piece Component](/model-5pieces-10Alpha-V2.png)

> âœ… Your bricks are now cast and ready  
> Next step: **placing and connecting them** to build your final model ğŸ”—


---

## ğŸ”— Connect the Bricks (Model Connections - Con)

Now that you've placed your **Pieces**, it's time to tell Semio how they connect ğŸ”—  
Think of this like writing the **assembly instructions** for snapping bricks together ğŸ§²

Each **Connection** says:  
ğŸ‘‰ *"Connect this Port on one Piece to a Port on another Piece"*
<br />

![ğŸ“¤ sketch drawing](/sketch-drawing-connections.png)


### ğŸ§­ Set the Connection

To create a connection, you need to define four values:

1. ğŸ†” **Connected Piece ID (`CdPc`)** â†’ the Piece you're connecting *from*  
2. âš“ **Connected Piece Port ID (`CdPo`)** â†’ the Port you're connecting *from*  
3. ğŸ†” **Connecting Piece ID (`CgPc`)** â†’ the Piece you're connecting *to*  
4. âš“ **Connecting Piece Port ID (`CgPo`)** â†’ the Port you're connecting *to*

---

Put simply:  
â¡ï¸ **Connect this Port on this Piece â†’ to that Port on that Piece**


---

##### ğŸ§© Example: Connecting Two Pieces

ğŸ§± Before snapping the full model together, letâ€™s start small â€” by connecting the **first two bricks**.  
Weâ€™ll connect Piece `Yel` to Piece `Red-T`, using their **west-facing Ports**.

From the sketch, we can tell:

- Use the **`w` (west)** Port of `Yel`  
- Connect it to the **`w` (west)** Port of `Red-T`

So the connection looks like this: 
`Con(Yel:w â†’ Red-T:w)`

![Connection Example](/mode-connection-grasshopper.png)

This tells Semio:  
**Snap the west Port of `Yel` to the west Port of `Red-T`**

![Set Connection](/set-connection-2pcs-alpha.png)

Once this first connection is in place, you can continue snapping all remaining bricks together using similar logic ğŸ§© 

![Set Connection](/mode-connection-5pcs-grasshopper.png)

ğŸ”— This Tells Semio:


1. `Con(Yel:w â†’ w:Red-T)`  
   ğŸ‘‰ **Snap the west Port of `Yel`** to the **west Port of `Red-T`**

2. `Con(Red-T:e â†’ e:Red-R)`  
   ğŸ‘‰ **Snap the east Port of `Red-T`** to the **east Port of `Red-R`**

3. `Con(Red-R:n â†’ w:Blu-T)`  
   ğŸ‘‰ **Snap the north Port of `Red-R`** to the **west Port of `Blu-T`**

4. `Con(Red-R:n â†’ w:Blu-B)`  
   ğŸ‘‰ **Snap the north Port of `Red-R`** to the **west Port of `Blu-B`**

---


![Set Connection](/set-connection-all-pcs-alpha.png)



### ğŸ¯ Adjust Snap *(Optional Step)*

When two Pieces are connected through Ports, Semio gives you control over **how the attached geometry is positioned** â€”  
without changing the Port itself.

These adjustments are applied **relative to the orientation of the Port**, based on how it was defined in the mold (Type).

ğŸ“Œ Use this when the geometry needs to be slightly offset â€” to float, shift, or align more precisely.

---

#### ğŸ” Move (Translation)

You can move the geometry in three local directions:

- **Gap** â¬…ï¸â¡ï¸ â†’ Creates a space between two connected elements by pushing the Piece forward or backward along the Port's axis 
  Ideal for separating elements or creating breathing room between parts

- **Shift** â†”ï¸ â†’ Moves the Piece side to side, across the plane of the Port  
  ğŸ“ Like nudging a LEGO brick left or right to line it up with studs underneath

- **Raise** â¬†ï¸â¬‡ï¸ â†’ Lifts or lowers the Piece vertically, perpendicular to the face it connects to  
  ğŸªœ Like lifting a brick slightly higher or lowering it onto the studs
  

  ![Connection Adjustment](/translation-parameter.gif)

---


#### ğŸ”„ Rotating (Orientation)

- **Rotate** ğŸ”ƒ  â†’ Rotates the Piece flat, around the Port's main vector
  ğŸ§­ Like spinning a round LEGO tile in place
- **Turn** ğŸ”„ â†’ Turns the Piece sideways, rotating it horizontally
  ğŸŒ€ Like twisting a LEGO hinge side to side
- **Tilt** ğŸ¤¸ â†’ Tilts the Piece forward or backward, around a vertical axis
  ğŸ¢ Like tilting a ramp or slope brick up or down

  ![Connection Adjustment](/Rotation-parameter.gif)

---


As we can see, the two Pieces we connected earlier donâ€™t align exactly as shown in the sketch ğŸ§©
<br />
![ğŸ“¤ sketch drawing](/sketch-drawing-45.png)
<br />
This is where the optional step of adjusting the snap comes in ğŸ› ï¸

Semio lets you fine-tune the position of a connected Piece after snapping ğŸ§²  
Youâ€™re not changing the Port itself âš“  
Instead, you're offsetting the **geometry** that comes with it ğŸ“

<br />
![Set Connection](/set-connection-2pcs.gif)




---


##### â• Connecting the Rest of the Pieces

Once `i` and `L1` are correctly aligned â¡ï¸  
you can continue connecting the remaining Pieces one by one â•

ğŸ“Œ Just follow the sketch:  
Each new Piece is snapped to the previous one using their matching **Ports** âš“  
â€” and adjusted as needed to match the layout.

ğŸŒ€ If a connected Piece isnâ€™t facing the right way,  
you can **rotate it individually** â€” Semio allows per-piece rotation without breaking the connection logic ğŸ”„

ğŸ”— And thanks to Semioâ€™s **chain behavior**,  
when you move or rotate one Piece, all the connected Pieces after it will **update automatically** ğŸ’«


![Set Connection](/set-connection-3pcs.gif)

![Set Connection](/set-connection-5pcs.gif)

---

:::note
ğŸ“Œ You can place Ports exactly where the geometry should land â€” or adjust the Piece after snapping using Gap, Shift, Raise, or Rotate.  
emio supports both strategies â€” choose what fits your design logic best ğŸ§±âœ¨
:::



---

## ğŸ—ï¸ Build the Design (Model Design - Dsn)

Now that you've created your **Pieces** and defined their **Connections**, it's time to bring them all together into a final **Design** ğŸ§°


### ğŸ§© What is a Design?



A **Design** in Semio is your full model â€” created by snapping together specific **Pieces** ğŸ§± using their **Connections** ğŸ”—

It doesnâ€™t just describe geometry ğŸ‘ï¸ â€” it defines how each part fits, aligns, and works within the system ğŸ§   
You're building not just a shape, but a **smart, modular structure** ğŸ§¬

ğŸ§± Think of it like a finished LEGO build:  
Youâ€™re not just stacking bricks â€” youâ€™re creating a model where every part has a **role** ğŸ­, a **position** ğŸ“, and a **purpose** ğŸ¯



---

### ğŸ› ï¸ Assembling the Design

To build your Design in Semio (e.g. in Grasshopper), youâ€™ll use the `Model Design` component.  
This is where you **bring together all the Pieces and Connections** to form your complete model ğŸ§©

Youâ€™ll provide three main inputs:

1. **Design Name** (`Dn`) ğŸ·ï¸  
   A unique name for your model â€” like `"Logo Example"` or `"Spaceship"`.

2. **Pieces** (`Pcs`) ğŸ§±  
   A list of the Pieces youâ€™ve created â€” each one linked to a Type, Variant, and unique ID.

3. **Connections** (`Con`) ğŸ”—  
   A list of the snapping rules â€” telling Semio how the Pieces are connected through their Ports.

---


**Example:**

![Model Design Example](/model-design.png)


---
## âš™ï¸ Workflow Mechanics 


Now that we've covered the core concepts of Semio, let's take a closer look at how the components actually work â€”  
and explore the key features of the Semio workflow inside Grasshopper

### ğŸ› ï¸ Grasshopper Workflow

Semio doesnâ€™t change **how** Grasshopper works â€” it changes **what** youâ€™re working with.  
Youâ€™re no longer just wiring geometry â€” youâ€™re wiring **design intent** ğŸ’¡

- **Types** ğŸ§± â€“ Brick molds with meaning, not just shapes  
- **Pieces** ğŸ§© â€“ Placed bricks that follow system logic  
- **Connections** ğŸ”— â€“ Rules that control how elements relate  
- **Designs** ğŸ§° â€“ Full assemblies of smart, connected pieces

This shift lets you create not just geometry â€” but structured, adaptable systems ğŸ§ 

---

Semio components behave just like regular Grasshopper components ğŸ§©

- ğŸ“‹ You still work with **lists** and **data trees**  
- ğŸ”¢ Items are matched by **index** or **branch**

Want to set a **gap** â¬…ï¸â¡ï¸ or a **rotation** ğŸ”?  
Just provide a matching list of values â€” each one applies to the corresponding item in your list of **Connections** or **Pieces**.

---


---



### ğŸ”„ Contruct, Deconstruct, Reconstruct


In Semio, **Model components** like `Model Type`, `Model Piece`, `Model Connection`, and `Model Design` follow a shared logic:  
theyâ€™re not just builders â€” theyâ€™re also **editors** and **inspectors**.

Each component supports three fundamental actions:

---

##### 1. ğŸ”¨ Construct

Each Model component can **create** a structured Semio object from your inputs:

- `Model Type` â†’ outputs a `Ty` (Type)
- `Model Piece` â†’ outputs a `Pc` (Piece)
- `Model Connection` â†’ outputs a `Cn` (Connection)
- `Model Design` â†’ outputs a `Ds` (Design)

These are Semioâ€™s core data types â€” they carry geometry, logic, metadata, and relationships.

---

##### 2. ğŸ” Deconstruct

You can also use the same component to **inspect** or **extract** the inner structure of a Semio object, and all its inputs will populate with the current values, like unpacking a brick to see how it was made.

---

##### 3. ğŸ” Reconstruct / Modify

In Semio, you can update any modeled object â€” like a Type, Piece, Connection, or Design â€”  
by feeding its output back into the **first input** of the same Model component.

- `Ty` â†’ Type ğŸ§±  
- `Pc` â†’ Piece ğŸ§©  
- `Cn` â†’ Connection ğŸ”—  
- `Ds` â†’ Design ğŸ§°  

When you do this, you can redefine any part of the object (like its name, geometry, plane, or metadata).  
Only the inputs you change will be updated â€” everything else stays exactly as it was

---
### ğŸ§ª Example Use Case
<br />

#### ğŸ§© Modify a Piece

You can modify **any aspect** of a Piece â€” such as its **name**, **placement**, or other construction parameters by feeding its `Pc` output back into a new `Model Piece` component ğŸ§©

Semio will only override the inputs you change â€” everything else stays exactly the same ğŸ¯

> _E.g. In the "Hello Semio" logo example, rotating the first Piece flips all connected Pieces as well â€” because theyâ€™re linked logically_  
_


  ![Reconstruct Piece](/reconruct-piece-2.png)

  ![Reconstruct Piece](/reconruct-piece.png)

#### ğŸ”— Adjust a Connection

You can adjust any **transformation or rotation parameters** of a Connection by  
plugging the `Cn` output back into a new `Model Connection` component ğŸ”

Semio will only update the values you change â€” all other settings will remain as they were ğŸ”’  
This makes it easy to fine-tune how two Pieces are connected without rebuilding the whole logic ğŸ”§

> _E.g. You can change the gap, shift, or rotation of an existing Connection, and all downstream geometry will update automatically._



  ![Reconstruct Con](/reconstruct-connection.png)
  ![Reconstruct Con](/reconstruct-connection-2.png)
  ![Reconstruct Con](/reconstruct-connection-3.png)

#### ğŸ§± Update a Type

You can update a **Type** by feeding its `Ty` output back into the same `Model Type` component ğŸ”  
This lets you modify its **Representation**, **Ports**, or **metadata** â€” without changing anything else.

> _E.g. Swapping a simplified geometry file for a detailed one, or updating tags like material or category._


---

#### ğŸ§° Refactor a Design

To modify a full **Design**, feed its `Ds` output into a new `Model Design` component ğŸ”  
You can update the **Design name**, reorganize the structure, or tweak how certain Pieces are connected.

> _E.g. Renaming a layout, replacing a few bricks, or adjusting a connection â€” without touching the rest._

---

#### ğŸ–¼ï¸ What Happens Next?

To **see** your model, plug everything into the `Preview Design` component ğŸ‘€  
It displays all your Pieces in place â€” fully connected, correctly oriented, and ready to go ğŸ§±


:::note
In Semio, nothing is visualized automatically

This logic stays abstract until you pass it to the `Show Design` component â€”  
only then is everything **combined and visualized** as a complete model
:::