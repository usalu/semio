- title: ğŸ§± Create Brick Molds
  description: All steps to break down, mold, and make variants of your model bricks.
  sidebar:
  order: 2
-

import { Steps, TabItem, Tabs } from "@astrojs/starlight/components";

As mentioned earlier in _[Thinking in semio](/think-in-semio/)_,
A _Type_ is your brick mold ğŸ§± The Blueprint behind each Brick
It defines not just the shape, but also the design meaning and connection logic ğŸ”§

-

# ğŸ§© What Are the "Molds" in This Example?

Take a look at your sketch ğŸ‘€
You'll see five elements that follow the _same basic shape_, just stretched to different lengths ğŸ“

Even though the final Design includes five Pieces, they're made from only _three distinct shapes_
with two of them used twice â€” giving us _three Variants of one Type_ ğŸ”¢

ğŸ§± Think of it like a LEGO brick that comes in 2-stud, 4-stud, and 5-stud versions â€”
same shape logic, just scaled ğŸ“

If the shape were completely different â€” like a triangle, window, or roof â›°ï¸ğŸªŸğŸ 
That would count as a _new Type_ altogether

-

# ğŸ§  Modeling with Meaning

When you think of a mold, the first thing that comes to mind is usually its _shape_ â€” the geometry ğŸ§±âœï¸
But in semio, the _mold_ is what combines _shape_ with _meaningful design information_ ğŸ’¡

In traditional Grasshopper workflows, youâ€™re modeling with _raw data_ â€” points, curves, and surfaces without embedding _design intent_ ğŸ§¬
You build logic around it, but that logic stays detached â€” abstract, custom, and often fragile.

> In _semio_, the mold connects geometry with design intent directly ğŸ§ 
> You're not referencing arbitrary geometry â€” you're referencing _relationships_, _roles_, and _rules_ ğŸ§©

For example:
ğŸ‘‰ Instead of saying "connect point (x, y, z) to Brep edge 23"
ğŸ‘‰ You say "connect the _door_ to the _living room_" ğŸ›‹ï¸ğŸšª
ğŸ‘‰ Or in LEGO terms: "ğŸªŸ _snap the window brick onto the top of the wall_" ğŸ§±

This is what gives semio its strength â€” youâ€™re not just building shapes,
youâ€™re building a _semantic system_ that adapts, scales, and speaks your design language ğŸ¯ğŸ—£ï¸

-

# ğŸ§° Create a Brick Mold ([Type](/think-in-semio/#type) â€“ Ty)

Letâ€™s begin by modeling the mold shown in the sketch
This will serve as the base for generating its _Variants_ ğŸ§©

![ğŸ“¤ sketch drawing](/sketch-drawing-mold.png)

Before we start building, letâ€™s go over the essential elements that define a _Type_ ğŸ§±:

- ï¸ _Name_ â†’ A unique name to identify your Type and reuse it in different designs ğŸ·
- _Geometry (Representation)_ â†’ The 3D shape attached to the Type â€” it gives the piece its visual form âœ¨ ğŸ§±
- _Connection Points (Ports)_ â†’ The snap points where the piece connects to others in the system ğŸ”— ğŸ§²

Now letâ€™s take a closer look at how these elements come together â€” and start modeling our first _brick mold_ ğŸ› ï¸

<Steps>
<ol>

<li>

# ğŸ·ï¸ Name Your Mold ([Type](/think-in-semio/#type) Name - Na)

Clear, consistent names in semio make everything easier down the line âœ…
Especially when your project grows and you're working with many _Types_, _Variants_, and _Pieces_ ğŸ”„

Good names help you:

- _Navigate_ your system ğŸ§­
- _Understand_ relationships ğŸ”
- _Make connections_ that are easy to track ğŸ”—

:note
Use names you'd use in a real project â€” specific, descriptive, and purposeful ğŸ“
:

ğŸ‘‰ In our example, weâ€™ll name our Type _"Profile"_
because the shape we're modeling is based on a _standard manufactured wood profile_ ğŸªµ

-

</li>

<li>

# ğŸ§Š Attach Geometry (Representation â€“ Rp)

In semio, the process of adding geometry to a Type is called _modeling its Representation_ ğŸ› ï¸
A _Representation_ is anything that visually or symbolically _represents a Type_ ğŸ§±
It helps you _see or recognize_ the Type â€” without defining its logic or behavior ğŸ§ 

In most cases, this will be a _3D geometry_, like in our example
But it can also be:

- A 2D drawing or diagram âœï¸
- A symbolic icon or block ğŸ”³
- A label, file, or reference ğŸ”–

ğŸ’¡ Because Representations are separate from the logic of the system, theyâ€™re fully flexible:

- You can start modeling your system without one ğŸš§
- You can add or update it later ğŸ› ï¸
- You can switch between levels of detail depending on the design phase ğŸ”

In this example, weâ€™ll use a _simple 3D shape_ to represent our brick molds we need to create ğŸ§©

-

# ğŸ”§ Modeling Representation

There are two simple steps to create a _Representation_:

- ï¸ _Build the Geometry_ ğŸ› 
  Model the physical form of your brick â€” the shape that will appear in your design

- _Link it to the Type_ ğŸ“
  Connect the geometry to a specific Type, so semio knows how to display and use it in your design space

Letâ€™s take a closer look at the _brick mold_ in our example ğŸ‘€
It always follows the _same basic shape_ ğŸ§±
A _rectangle thatâ€™s cut at an angle_ âœ‚ï¸ â€” just repeated in different lengths ğŸ“

As we saw in the sketch, its size is described using _two parameters_:

- `W` â†’ the width of one brick unit
- `n` â†’ the number of units in length

-

In _semio_, you can attach geometry to a Type in different ways ğŸ”„
You can pick the method that best fits your _workflow or tool_.

Letâ€™s take a look at how that works in practice ğŸ‘‡

<Tabs>

<TabItem label="File-Based Reference (ğŸ” Recommended)">

In _semio_, Representations are typically referenced through _external geometry files_ ğŸ—‚ï¸
â€” even when those files are generated inside _Grasshopper_

This approach keeps your workflow _clean_, _modular_, and _easy to update_ ğŸ§¼
It also makes your design system more _reusable_ and _scalable_ ğŸ”

While the modeling process itself isnâ€™t the focus of this tutorial,
hereâ€™s the key takeaway:
Youâ€™ll need to follow _three simple steps_ to attach your geometry as a _Representation_ ğŸ§±

-

# ğŸ› ï¸ Geometry Modeling

Since our shape follows a clear logic ğŸ§ 
we use a _parametric Grasshopper definition_ to generate the geometry of the brick mold ğŸ§±

This is useful because it lets us generate _all the different Variants_ of this brick seen in the sketch
using a single logic controlled by the parameters `n` and `W`
which define the brickâ€™s length and width ğŸ“

![ğŸ“ Geometry Generation](/attach-geometry-crop.gif)

-

# ğŸ’¾ Geometry Export

After generating the geometry,
we need to _export it as a `.glb` file_ so it can be attached as a _Representation_ ğŸ’¾

Weâ€™ll use a _simple workflow_ that automates this export ğŸ¦¾
You can place it _directly after_ your geometry generation step in Grasshopper ğŸ¦—

-

ğŸ” The Export Workflow Looks Like This:

![ğŸ“¤ Export Geometry](/export-geometry.png)

-

# ğŸ—‚ï¸ Set the Export Location

Use the `Dir` and `Path` components to define the directory path
This determines where the exported file will be saved

# ğŸ“ Build the File Name

Use `Concat` to generate the file name dynamically
Combine the Type name and Variant (e.g. `profile` + `2`) â†’ `profile_2.glb`

# ğŸ§© Assemble the Full File Path

Another `Concat` merges directory + file name:
`C:\Users\Users\Downloads\profile_2.glb`

# ğŸ“ Prepare the Geometry

> ğŸ› ï¸ You've already modeled the geometry earlier in your Grasshopper definition.
> Now it's time to _export_ it â€” so semio can use it as a _referenced Representation_ ğŸ’¾

- Convert the geometry into the required format (e.g. _Mesh_ for `.glb`) âœ…
- Pass it into the `iGeo` component to export it as a `.glb` file ğŸ“¤

Your file directory should now look like this:

![ğŸ“¤ Exported file](/file-export-Profile-2-.png)

-

:note
âš™ï¸ This method combines the _parametric power of Grasshopper_ with the _modular logic of semio_
ğŸ“¤ Every time a parameter changes, the file can be _re-exported automatically_ â€”
ready to be referenced in the next step
:

-

# ğŸ”— Referencing the Exported File

The exported file (e.g. `profile_2.glb`) is linked to the _`Ur` input_ of the _Model Representation_ component (`~Rep`)
This tells semio _where to find the geometry_ that represents your Type.

- The _`~Rep` (Model Representation)_ component takes the `Ur` file path and creates a Representation: ğŸ§©
  â†’ `Rep(model/gltf-binary)`

- This Representation is later connected to the _`Typ` (Model Type)_ component â€” ğŸ”—
  so that your Type is linked to its visual form

![ğŸ“ Reference Geometry](/reference-geometry.png)

-

# ğŸ” Why Use File-Based Referencing?

Even inside Grasshopper, semio requires a _file-based snapshot_ of your geometry â€”
a static file that captures what your brick mold looks like at a specific moment.

Hereâ€™s why that matters:

- ï¸ If your geometry is dynamic or parametric, it still needs to be _exported to a file_ âš™
- semio connects to that file â€” not the live Grasshopper preview ğŸ”—

> ğŸ’¡ This keeps geometry _modular_, _portable_, and easy to reuse
> ğŸ§± It also supports _chunking_ â€” breaking down large designs into smaller, manageable parts
> ğŸŒ And it allows smooth transition between _Grasshopper_ and _semio Sketchpad_

</TabItem>

<TabItem label="Direct Reference">

You donâ€™t always need to embed geometry directly into a Type ğŸ§±
In some cases, you can skip integration and reference the geometry directly in Grasshopper instead ğŸ›ï¸

Just pass the geometry â€” either as a Geometry ğŸ§Š or Object ğŸ§© â€” straight into the Preview Design component ğŸ‘€
This lets you visualize your Design using custom shapes without embedding them into the Typeâ€™s definition ğŸ”

ğŸ‘‰ Weâ€™ll explore this option in a later step.
âš ï¸ Just note: this method is for visualization only â€” the geometry wonâ€™t be part of the mold itself

</TabItem>

</Tabs>

-

# ğŸ§ª Switching the Representation

As introduced earlier, when you give a _Type_ its shape in semio, you're attaching a _Representation_ â€”
a piece of geometry that shows what the brick looks like visually ğŸ‘ï¸

But this geometry isnâ€™t fixed â€” it acts more like a _placeholder_ ğŸ§ 
That means you can _change or swap_ the Representation at any time _without breaking your design logic_ ğŸ”

You can think of it like a _costume_ for your Type ğŸ­
The name, role, and connections stay the same â€” you're just changing how it looks on stage ğŸ¬

This flexibility is especially useful when working across _different levels of detail_ in a project ğŸ§©

Just like architects might use _blocky volumes_ for urban massing ğŸ™ï¸
and _detailed profiles_ for close-ups or fabrication ğŸªŸ
semio lets you swap the _look_ without changing the _logic_ ğŸ”„
Same brick â€” different shell ğŸ’¡

# ğŸ¬ One Brick, various Representations

To illustrate this concept, we created _two geometry files_ for the _same brick mold Type_:

-

<Tabs>

<TabItem label="ğŸ” Detailed Version">

This version uses the _fully detailed geometry_ of the piece ğŸªµ
A rectangle cut at an angle and extruded into a realistic wooden profile âœï¸
It includes every visible detail in 3D: full depth, edges, and joinery-ready shapes ğŸ”

![ğŸ“ Switch Representation](/Switch-Representation.png)
![ğŸ“ Filename](/Profile-2-detailed.png)

Best for:

- Joinery and production planning ğŸªš
- Material-specific outputs ğŸ“
- ï¸ Detailed documentation and renders ğŸ–¼

</TabItem>

<TabItem label="ğŸ“„ Sheet Version">

This version is a _flat sheet simplification_ ğŸ“„
A single-surface geometry that represents the general size of the piece ğŸ“
It captures only _one dimension_ and skips all 3D detail ğŸš«

![ğŸ“ Switch Representation](/switch-representation-sheet.png)
![ğŸ“ Filename](/Profile-2-simplified.png)

Use this when:

- Only the 2D footprint is known ğŸ“
- ï¸ The full shape is not finalized yet âœ
- You need fast previews or early-stage coordination âš¡

</TabItem>

<TabItem label="ğŸ“¦ Block Version">

This version is a _bounding box simplification_ ğŸ“¦
A simple block that approximates the pieceâ€™s volume â•
It includes _two dimensions_ but omits exact geometry ğŸ§Š

![ğŸ“ Switch Representation](/switch-representation-Block.png)
![ğŸ“ Filename](/Profile-2-simplified.png)

Best for:

- Early-stage layouts and feasibility checks ğŸ§ª
- ï¸ Quick iterations and high-speed previews âš™
- Placeholder geometry before final detailing ğŸ§Š

</TabItem>

</Tabs>

-

Even though these two Representations _look very different_
They both belong to the _same Type_ âœ…

The _Name_, _Variant_, _Ports_, and _logic_ stay exactly the same
Only the appearance changes ğŸ­

This means you can _design and assemble_ everything using lightweight placeholders ğŸ§©
Then _swap in the detailed version_ when you're ready for presentation, communication, or fabrication ğŸ§°

This separation of _logic and form_ is what makes semio workflows flexible, scalable, and robust ğŸ”„
From early concept to detailed design to collaborative development ğŸ¤

</li>

<li>

# âš“ Add Snapping Points ([Ports](/think-in-semio/#port) - Po)

Once your brick mold has a visual shape â€” its _Representation_ â€”
the next step is to define _how it connects to other bricks_

Thatâ€™s what _Ports_ are for ğŸ§²
They act as snap points that tell semio where and how a brick can attach to others

-

# ğŸ§© What Do You Need to Define a Port?

In the semio Grasshopper plugin, each Port is defined with three main inputs:

- ï¸ _Port ID_ ( `Id` ) ğŸ·
  A unique name for the Port â€” like a tag or label used to connect it later
  Examples: `"n"`, `"bottom"`, `"hingePoint"`

- _Point_ ( `Pt` ) ğŸ“
  The exact spot where the connection happens â€” like placing a stud on a LEGO brick ğŸ§±
  You place this carefully on your geometry, right where the snapping should occur

- ï¸ _Vector_ ( `Dr` ) â¡
  The direction the Port faces â€” telling semio which way the brick will connect ğŸ”
  Itâ€™s what lets semio rotate and align the bricks correctly when snapping them together

![ğŸ“ Ports](/model-port-alpha.png)

-

# ğŸ“ Port Location (`Pt`)

When modeling Ports, itâ€™s not just about _where_ pieces touch â€”
itâ€™s about building a _clear and reusable logic_ that works across all Variants ğŸ§ ğŸ”

-

Hereâ€™s how to define your Ports effectively:

- _Choose stable, meaningful locations_ ğŸ§±
  Choose positions that are geometrically logical â€” like the _center of a face_, an _edge midpoint_, or a _corner_ ğŸ§©
  Avoid placing them randomly â€” symmetry and regular patterns help your logic stay clean â™»ï¸

- _Keep positions consistent across Variants_ ğŸ“
  Even if your bricks differ in size or shape, place Ports in the _same relative location_ ğŸ”„
  This way, your connection rules stay valid across all versions of a Type ğŸ§°

- _Donâ€™t worry about perfect alignment_ ğŸ¯
  Ports donâ€™t need to be _exactly_ placed.
  semio lets you adjust each Pieceâ€™s _position and rotation_ _after_ snapping ğŸ› ï¸
  So prioritize clear logic over micrometer precision ğŸ˜Œ

-

Thereâ€™s no strict rule for how many Ports to add â€” it depends on how much flexibility your system requires:

- _Fewer Ports_ â†’ simpler, more controlled snapping ğŸ”’
- _More Ports_ â†’ more layout options and greater orientation flexibility ğŸ”“
- _Plan ahead_ â†’ add Ports you might need later, even if theyâ€™re not used right away ğŸ§ 

ğŸ‘‰ _In our example, we place four Ports â€” one at the center of each edge of a four-sided profile_ ğŸ§±

-

# ğŸ’¡ Port Direction (Dr)

Every Port needs a _direction_ â€” a vector that tells semio which way the connection should face ğŸ§­
This is how semio knows how to align and snap your Pieces together correctly ğŸ§²

Hereâ€™s how to define Port directions clearly:

- _Use clean, simple vectors_ ğŸ“
  Stick to basic axes like _X, Y, or Z_ relative to the face the Port sits on. It makes snapping easier and logic more readable ğŸ§ 
  Avoid random or diagonal directions unless needed

- ï¸ _Be consistent across Variants_ â™»
  Ports donâ€™t need to be perfectly precise â€” but they _must stay consistent_
  This ensures all your bricks connect correctly no matter the shape or version ğŸ”§

ğŸ‘‰ _In our example, each Port faces straight out â€” perpendicular to the edge itâ€™s placed on_ ğŸš€

-

# ğŸ·ï¸ Port ID (Id)

A _Port ID_ is the name you give to each Port ğŸ·ï¸
This name is how semio knows _which Port to connect_ when snapping Pieces together

For example, you might say:

> "Connect the `top` Port of Piece A to the `bottom` Port of Piece B"

You can use _any naming system_ â€” as long as itâ€™s clear and consistent:

- Common examples: `n`, `s`, `e`, `w` â€” for north, south, east, and west ğŸ§­
- Custom names: `top`, `bottom`, `hinge`, `plug`, `windowDock`, etc. ğŸ§²

ğŸ’¡ _Tip:_ Pick a naming system thatâ€™s easy to understand and stick to it
It helps you stay organized and makes teamwork or AI assistance much easier ğŸ¤

-

Together with the _Pt_ (position) and _Dr_ (direction), the _Id_ completes each Port definition:
Each row in the three lists defines one Port â€” so all lists must be the _same length_ to stay in sync ğŸ§©

-

Now you can see how the three inputs â€” Id, Pt, and Dr â€” work together to create Ports.
Each Port is defined by one entry from each list, so the lists must be the same length.
This ensures that every snapping point has a matching ID, position, and direction

</li>

<li>

# ğŸ§± Assemble the Mold (Model [Type](/think-in-semio/#type)

Once youâ€™ve defined all parts of your brick mold
the _Name_, _Variant_, _Ports_, and _Representation_
you can assemble them using the `Model Type` component (`Typ`) ğŸ§°

Here's what you plug in:

- ï¸ _Name_ â€” the shared identity of the mold (e.g. `"Profile"`) ğŸ·
- _Variant_ â€” the specific version number (e.g. `"2"`) ğŸ”¢
- _Ports_ â€” the snapping points and directions (e.g. `n`, `s`, `e`, `w`) ğŸ§²
- _Representation_ â€” the geometry that defines the brick's shape ğŸ§Š

![ğŸ“ Model Type](/model-type.png)
![ğŸ“ Model Type](/model-type-geo.png)

-

ğŸ¯ The result is a complete _Type_
A reusable brick mold that carries both shape and connection logic

For example, `Typ("Profile", 2)`
creates Variant `2` of the `"Profile"` mold
a 2-unit-long brick ready to be placed in your Design ğŸ§±

-

</li>

</ol>
</Steps>

# ğŸ§¬ Create Mold Versions (Variants of [Type](/think-in-semio/#type)

![ğŸ“¤ sketch drawing](/sketch-drawing-variant.png)

Now that you've created your base _Type_, it's time to generate _Variants_ â€” based on the _unit count `n`_ shown in the sketch ğŸ”¢

Each Variant is built from the _same mold_, just stretched or scaled to a different length ğŸ“
Think of it like longer or shorter LEGO bricks of the same kind ğŸ§±
Since they follow the same logic and structure, we treat them as _Variants_ of one _Type_ â€” not separate Types â™»ï¸

Examples from our sketch:

- `Variant 2` â†’ 2 units long ğŸŸ© ğŸŸ©
- `Variant 4` â†’ 4 units long ğŸŸ© ğŸŸ© ğŸŸ© ğŸŸ©
- `Variant 5` â†’ 5 units long ğŸŸ© ğŸŸ© ğŸŸ© ğŸŸ© ğŸŸ©

-

# ğŸ” Modeling a Variant

-

# âœ… What Stays the Same

- ï¸ _Type name_ â€” youâ€™re still using the same underlying mold ğŸ·

# ğŸ”„ What Changes?

- _Variant name_ â€” a unique label like `2`, `4`, or `5` to distinguish the version ğŸ”¢
- _Representation_ â€” new geometry that reflects the Variantâ€™s shape or size ğŸ§Š
- _Ports_ â€” same logic, but positioned relative to the new shape ğŸ§²

-

# ğŸ› ï¸ Modeling Steps

1. ğŸ·ï¸ Set the _Type name_ (same as the original mold)
2. ğŸ”¢ Assign a new _Variant name_
3. ğŸ§Š Attach the _Representation_ â€” the geometry for this Variant
4. ğŸ§² Add the _Ports_ â€” positioned consistently
5. ğŸ§± Use the `Model Type` component to combine everything into a complete Variant

-

:note
Keep Port positions consistent across all Variants â€” it ensures easier snapping and logic reuse
:

âœ… Thatâ€™s it â€” same mold, new shape, fully ready for modular design

-

# ğŸ’¡ Advanced Tip: Use Clusters to Generate Variants

In Grasshopper, a great way to handle multiple Variants is with a _Cluster_

Since most Variants share the same logic and differ by only one or two parameters, a Cluster helps you:

- Model the logic _once_ ğŸ”
- Generate all Variants _efficiently_ âš¡
- Keep your script _clean and modular_ ğŸ§¼

![ğŸ“ Variant GIF](/Type-1-to-5-crop.gif)

<Tabs>

<TabItem label="ğŸ“‚ File-Based Geometry Reference">

_Inside the Cluster:_

You define the full logic:

- Generate and export geometry ğŸ§Š
- Link the exported file via `Model Representation` ğŸ“
- Place Ports using `Model Port` ğŸ§²
- Create the Variant using `Model Type` ğŸ§±

![ğŸ“ Cluster](/cluster-type-inside-ALpha.png)

_Outside the Cluster:_

You only feed in the changing inputs:

- `n` â†’ the unit count (e.g. 2, 4, 5) ğŸ“
- ï¸ Variant name â†’ often also `n` ğŸ·
- Directory of the GH file ğŸ“
- Export toggle ğŸ”˜

![ğŸ“ Cluster](/type-cluster-file-reference-Alpha.png)
![ğŸ“ Cluster](/file-export.png)

</TabItem>

<TabItem label="ğŸ§± Direct Geometry Reference">

_Inside the Cluster:_

You define the full modeling logic directly, without saving external files:

- Generate geometry ğŸ§Š
- Place Ports using `Model Port` ğŸ§²
- Create the Variant using `Model Type` ğŸ§±

![ğŸ“ Cluster](/cluster-type-inside-direct.rfrc.png)

_Outside the Cluster:_

Only the changing parameters are connected:

- `n` â†’ the unit count (e.g. 2, 4, 5) ğŸ“
- ï¸ Variant name â†’ often also `n` ğŸ·

![ğŸ“ Cluster](/type-cluster-direct-reference-Alpha.png)

</TabItem>
</Tabs>

-

âœ… _Bonus:_ This workflow keeps your file organized, scalable, and easy to expand â€” perfect for growing your Kit later on ğŸ§©
