---
title: 🧱 Create Brick Set
description: All steps to break down, mold, and make variants of your model bricks.
sidebar:
  order: 2
---

import { Steps, Tabs, TabItem } from "@astrojs/starlight/components";


## 🧰 Create Brick Mold (Type)

As mentioned earlier in **Thinking in semio**, a **Type** is like a **brick mold**.  
 You're not just drawing geometry — you're designing a **template** that combines shape with meaningful design information.

##### 🧩 What are the "Molds" in this example?

Each of the five elements in your sketch is a **variant** of the **same Type** —  
 meaning they all share the same shape logic but vary in size.

So while you see five Pieces in the final Design, they're made up of **three unique shapes**,  
 with two of them repeated once — making **three Variants of one Type**.

##### 🔧 What do we need to create these Molds?

To define a Type in semio, you'll model both its **form** and its **behavior**.  
 Let's go over the essential ingredients:

- **🏷️ Name** → Every Type needs a unique name that helps you identify and reuse it later.

- **🏷️🧱 Representation** → This is the geometry linked to the Type. Think of it as the visual shape of your brick.

- **🧲 Ports** → These are the snap points. You'll define exactly where the brick connects to others.

In the next steps, we'll walk through how to set up each of these elements to build a complete, reusable mold — just like designing a custom Lego piece.

<Steps>
<ol>
<li>
### 🏷️ Name Your Mold

##### 📚 General: Why Naming Matters

Giving clear and consistent names to elements in semio **pays off later** — especially during the design and connection phases.  
 When your project grows and you're working with multiple Types, Variants, and Pieces, meaningful names help you:

- stay organized

- avoid confusion

- quickly identify components

- enable smoother teamwork and collaboration

##
</li>
<li>
### 🧊 Attach Geometry (Model Representation)

In semio, geometry is more than just shapes — it's tied to **meaning** 💡  
 This is different from regular Grasshopper workflows, where geometry is just raw data.

In semio, you're building your own **design language** — like sketching with intent ✏️  
 You don't say "connect point (x, y, z) to Brep edge 23."  
 You say "connect the door to the living room" —  
 or in Lego terms: "snap the window brick to the top of the wall" 🪟🧱

🔗 The geometry is still there — but now it's **semantic**.  
 You're connecting **components with purpose**, not just lines or meshes.

We call this step **Modeling a Representation** 🧩 —  
 it's where you attach a visual form to your brick mold (Type),  
 so that every **beam**, **panel**, or **profile** knows what it is and where it fits ✅

---

##### 🧊 How to Attach Geometry

To model a Representation, you first need to create the **geometry** — the body of your building block.

semio lets you attach geometry to a Type in **two main ways**, each with its own strengths 🚀


---

💡 **Tip:** Choose the method that fits your workflow best.  
 Want to dive deeper into the pros and cons? Learn more here 🔍

We will now discover a hands on of doing both on our example :

Lets try to model our shapes as you see is a rectangle, cut at an angle

As you can see the different design Parameters in the sketch :

- `W` = a single Unit Dimensions  
  `n` = Number of segments (length of each element

<Tabs>
<TabItem label="Direct Reference">
For now we will develop This Shape a logic has been created to generate it based on how many Units it has in its length.

We have created a Grashopper logic that first generate this Rectangular shape cut and then Create a wood profile out of this curve
</TabItem>
<TabItem label="File-Based Reference (🔁 Recommended)">
We could model the Geometry we want to attach at the end we reference a layer
</TabItem>
</Tabs>

| Feature                              |  Direct Reference                     |  File-Based Reference (🔁 Recommended) |
| :----------------------------------- | :---------------------------------------: | :------------------------------------------: |
| **Source**                           | Scripted/Modeled in Rhino/Grasshopper 🦗🦏 | External File 📁                            |
| **Speed & Flexibility (Prototyping)**|                     ✅                    |            ⚠️ Slower Initial Setup            |
| **Coupling & Reusability**           |      ⚠️ Tightly Coupled, Less Reusable    |          ✅ Loosely Coupled, Reusable        |
| **Modularity & Cleanliness**         |      ⚠️ Less Modular, Potential Clutter   |        ✅ Modular & Clean Organization       |
| **Updates (Connection Stability)**   |      ⚠️ Prone to Breaking Connections    |         ✅ Stable Updates, Intact Links        |
| **Teamwork & Scalability**           |      ⚠️ Difficult for Teams & Scaling   |         ✅ Ideal for Collaboration & Growth  |

File Linking files :

Her link to a Seperate page > Switching between different representations. Placeholder logic

Two Examples > Three different snapshots of iterative process. First when its still a box and then add Capsules windows and other detailing. Showcase how easy is it possible to iteratively Design and come back to the whole system switch between

Two main things should come out

1.Iterative process

2.Switching between versions

Just like in LEGO, you're making a mold that you'll reuse — not the bricks themselves.

---
</li>
<li>
### ⚓ Add Connection Points (Model Ports)

Once you've modeled the visual look of your brick mold (Representation), it's time to decide **where** these bricks connect to each other.  
 That's where **Ports** come in — the snap points that define where a Brick can attach 🧲

##### 🧩 What Do You Need to Define a Port?

In the semio Grasshopper plugin, each Port is defined with 3 main inputs:

- **A Point** 📍  
   This is the location where the connection happens.  
   Think of it as the exact stud or socket on your Lego brick. You choose this point carefully on the surface of your geometry.

- **A Vector** ➡️  
   This defines the direction the Port faces.  
   It's like saying: "This side is meant to connect outward."  
   The vector is especially important later when aligning pieces — because semio uses this direction to orient other parts when snapping.

- **A Port ID** 🏷️  
   This is the name of the Port — a label you'll use when connecting components.  
   For example: `"n"` (north), `"bottom"`, or `"hingePoint"`.

##### 🏷️ About Port IDs

A **Port ID** is the label you give to each Port.  
 This naming is important — because later, when you make connections, you'll say things like:

"Connect Piece A's `top` Port to Piece B's `bottom` Port."

You can choose any naming system — as long as it makes sense in your design logic.  
 In this example, we use:

- `n`, `s`, `e`, `w` — standing for **north, south, east, and west** 🧭

But in your own projects, you might use:

- `top`, `bottom`, `hinge`, `plug`, `outlet`, `windowDock` — or anything else 🔧

💡 **Tip**: Choose a consistent and meaningful naming system. It will make connecting components easier — and later on, it helps when working with AI or team members.

##### 🔎 Why Are Ports in the Middle in our example?

You might wonder:

"Why aren't the Ports placed exactly where the pieces touch?"

That's because semio lets you **adjust** the position and rotation of a Piece **after** it snaps.  
 So you can define Ports in logical, consistent places — like the center of a face — and still have full control over placement later.

This is especially helpful when modeling **Variants of the same Type**:  
 Keeping Port positions uniform means you can reuse logic more easily — even if the pieces are longer, shorter, or slightly different in shape.

##### 🧠 How Many Ports Should I Add?

That's up to you. Just like Lego bricks have multiple studs — even if not all of them are used — you can place multiple Ports to offer flexibility 🧱

But in semio, you decide **how much flexibility** you need:

- You can define only one Port per side 🔒

- Or add many, for more options 🔓

There's no "right" answer — it depends on your design logic.

Here more Grasshopper
</li>
<li>
### 🧱 Assemble the Mold (Model Type)

After modeling all the parts of your brick mold —  
 **Name**, **Variant**, **Ports**, and **Representation** —  
 you plug them into the `Typ` component.

- 🏷️ **Name** → e.g. "Profile"

- 🔢 **Variant** → e.g. 2

- 🧲 **Ports** → e.g. n, s, e, w

- 🧊 **Representation** → the linked geometry

🎯 The result is a complete **Type** —  
 a smart, reusable building block ready to be placed and connected in your Design.

Think of it as snapping all the mold info together — now you have your custom LEGO brick 🔧🧱

---
</li>
</ol>
</Steps>

## 🧬 Mold Versions (Variants of Type)
→ Use the same mold to make bricks of different sizes

Now that you've created your base **Type**, it's time to generate **Variants** — based on the **unit count `n`** shown in the sketch.

Each Variant uses the **same mold**, just stretched or scaled.  
 Think of it like longer or shorter Lego bricks of the same kind 🧱🧱🧱  
 Since they follow the same design logic, we treat them as **Variants** of one **Type**, not separate Types.

#### 🔢 From the Sketch:

- **Variant 2** → 2 units long

- **Variant 4** → 4 units long

- **Variant 5** → 5 units long

---

#### 🔁 How to Model a Variant in semio

To model a Variant, you follow **the same steps** as creating a Type —  
 but with **two key differences**:

1. **Reuse** the original **Type name**

2. **Assign** a **unique Variant name** (e.g. the unit count `n`)

This tells semio:  
 ➡️ "Same mold, different size."

✅ Just like with Types, you have **three ways** to reference geometry:

- Direct from Grasshopper or Rhino Layer

- External file (recommended)

---

#### 💡 Advanced Tip: Use Clusters to Generate Variants

In Grasshopper, a smart way to manage **Variants** is by using a **Cluster** —  
 essentially a reusable mold-maker that builds each version of your LEGO brick 🧱

Since Variants are mostly identical and only differ by one or two inputs,  
 the Cluster helps you model everything once and repeat only what's necessary.

**Inside the Cluster:**  
 You define the full Type logic —

- Geometry generation
- Representation attachment (Model Representation)
- Port placement (Model Port)
- Type creation (Model Type)

**Outside the Cluster:**  
 You feed in only what changes:

- `n` → the unit count (e.g. 2, 4, 5), which controls the shape size 📏

- Variant name → In this Case it is also `n` 🏷️

This way, you can generate multiple Variants from the same Type mold —  
 without duplicating anything or cluttering your canvas.

✅ **Bonus:** Keeps your file organized and scalable — perfect for growing your Kit later on.

Showcase the three different methods :

Cluster without referencing

Cluster with referencing Files

Note > If the Shape would be different you would create a new type instead of Variants of the same type


---

