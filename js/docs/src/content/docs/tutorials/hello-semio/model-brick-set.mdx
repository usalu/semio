---
title: 🧱 Create Brick Set
description: All steps to break down, mold, and make variants of your model bricks.
sidebar:
  order: 2
---

import { Steps, Tabs, TabItem } from "@astrojs/starlight/components";



As mentioned earlier in **[Thinking in Semio](/think-in-semio/)**, a **Type** is like a **brick mold**.  

You're not just drawing geometry — you're designing a **template** that combines shape with meaningful design information.

---

#### 🧩 What Are the "Molds" in This Example?

Take a look at your sketch — you'll see five elements that follow the **same basic shape**, just stretched to different lengths.

Even though the final Design includes five Pieces, they're made from only **three distinct shapes**,  
with two of them used twice — giving us **three Variants of one Type**.

🧱 Think of it like a LEGO brick that comes in 2-stud, 4-stud, and 5-stud versions — same shape logic, just scaled.

If the shape were completely different — like a triangle, window, or roof — that would count as a **new Type** altogether.


---

#### 🔧 What Do We Need to Create These Molds?

When you think of a mold, the first thing that comes to mind is usually its **shape** — the geometry 🧱✏️  
But in Semio, geometry is more than form — it serves as a **placeholder for meaning** 💡

In traditional Grasshopper workflows, geometry is just raw data 🧬  
But in Semio, it becomes part of your **design language** 🗣️🎨 — a way to represent **intent**, not just surfaces 🎯

For example:  
👉 Instead of saying "connect point (x, y, z) to Brep edge 23"  
👉 You say "connect the **door** to the **living room**"  
👉 Or in LEGO terms: "**snap the window brick onto the top of the wall**" 🪟🧱

🔗 The geometry still exists — but now it stands in for something more: **a role, a relationship, a meaning**.


---

## 🧰 Create a Brick Mold (Type - Ty)

Let’s begin by modeling the mold shown in the sketch. 
This will serve as the base for generating its Variants.

Before we start building it, let’s go over the essential elements that define a Type:

- **🏷️ Name** → A unique name to identify your Type and reuse it in different designs.  
- **🧱 Geometry (Representation)** → The 3D shape attached to the Type. It gives the piece its visual form.  
- **🧲 Connection Points (Ports)** → The snap points where the piece connects to others in the system.

Let’s take a look at the elements that make up a Type, and dive into modeling our first brick mold.

<Steps>
<ol>

<li>

### 🏷️ Name Your Mold (Type Name - Na)

Giving clear and consistent names to elements in Semio **really pays off later** — especially when designing and making connections.  
As your project grows and you're working with many Types, Variants, and Pieces, meaningful names make everything easier to navigate and understand.

📝 Try to name things the way you would in a real project — clear, specific, and with purpose.

---

</li>

<li>

### 🧊 Attach Geometry (Representation – Rp)


In Semio, when you give a Type its shape, you're adding a **Representation** 🧱  
This isn’t just visual geometry — it’s a **layer of meaning** that stands in for a design element.

Think of it like snapping a shell onto a LEGO mold — now your brick has a visible form 👀  
But that form isn’t fixed. A Representation is more like a **costume** — it can be swapped at any time, as long as it fits the logic.

Just like architects might use a blocky mass for urban models 🏙️ or detailed profiles for close-ups 🪟,  
Semio lets you change the **look** without changing the **design logic** 🔄  
Same brick, different shell — that’s the idea 💡

---

#### 🔧 How to Model a Representation

Creating a Representation works in two simple steps:
🧱 First, you build the geometry — the actual shape of your brick.
📎 Then, you attach that shape to your Type to give it a visual form.

Let’s take a closer look at the brick mold in our example.
It’s shaped like a rectangle cut at an angle, then stretched into a wooden LEGO-style profile.

We’ll use two parameters to define its size:

W → the width of one brick unit

n → the number of units in length 

In Semio, you can attach geometry to a Type in different ways — depending on what works best for your workflow
Let’s look at how that works in practice:



<Tabs>

<TabItem label="File-Based Reference (🔁 Recommended)">

Model the shape externally (e.g. in Rhino), then attach it to your Type by referencing a named layer.

### 🗂️ Referencing a File-Based Representation

In Semio, Representations are typically referenced through **external geometry files** — even when the geometry is generated inside Grasshopper.  
This approach helps maintain clean, modular workflows and supports flexible updates.

In this example, we’re exporting a `.glb` file and referencing it in a **Type** using the file-based method.

---

#### 🛠️ Geometry Generation & Export 

We use a **parametric Grasshopper definition** to generate the shape of the brick mold.  
This is helpful because we can define a logic that supports **all Variants** of a Type — controlled by the parameter `n`, which sets the brick's length.

While the modeling logic isn't the focus of this tutorial, the key takeaway is:

> 🧱 **We generate the geometry , and reference it via an exported file.**

---
#### 🧱 Exporting the Geometry to a File

Here’s what the script does:

- **Set the Export Location**  
  A directory path is defined using the `Dir` and `Path` components.  
  This determines where the exported file will be saved.

- **Build the File Name**  
  The file name is generated dynamically using `Concat`,  
  combining the Type name (e.g. `profile`) and the Variant (e.g. `2`) → `profile_2.glb`

- **Assemble the Full File Path**  
  A second `Concat` block merges the directory and file name:  
  `C:\Users\Users\Downloads\profile_2.glb`

- **Prepare the Geometry**  
  - Convert or prepare the geometry in the desired format (e.g. Mesh)  
  - The `iGeo` component then writes the `.glb` file to disk

---

#### 🧱 Referencing the File in a Type (Top Group)

The same file name (`profile_2.glb`) is passed to the **`Ur` input** of the `~Rep` component.  
This tells Semio where to find the exported geometry.

- The `~Rep` component uses this path (`Ur`) to create a Representation:  
  `Rep(model/gltf-binary)`

- This Representation is then connected to the **Type**, along with its **Name** and **Variant**.

> 💡 `Ur` stands for "URL" or file path — it’s how Semio links a Type to its geometry.

---

#### 🔁 Why File-Based?

Even when working inside Grasshopper, Semio requires a **snapshot** of the geometry —  
a static file that represents the shape of the brick mold at a given point in time.

This means:

- If you generate geometry dynamically, you still need to export it as a file  
- Semio references that **fixed file**, not a live Grasshopper definition

> 💡 This ensures geometry stays **modular and transferable** between Grasshopper and Semio Studio.






</TabItem>

<TabItem label="Manual Reference">



Here are the 


</TabItem>

</Tabs>

##### 💡 Tip: Choose the method that best fits your workflow.  
Want to go deeper into the pros and cons? Learn more here 🔍

---

#### 🧪 Representation as a Placeholder

Representations can be swapped — they’re just one way to **visualize** a design, not define it.  
That means you can use **different versions** of the same Type depending on your needs:

<Tabs>

<TabItem label="🔍 Detailed Version">

Use a high-detail Representation with features like joints, profiles, or textures — ideal for fabrication or close-up studies.

</TabItem>

<TabItem label="⚡ Simplified Version">

Use a simplified shape — fast to render and easier to work with at larger scales.

</TabItem>

</Tabs>

This flexibility helps keep your model lightweight while preserving the underlying logic.

</li>

<li>

### ⚓ Add Snapping Points (Ports - Po)

Once you've modeled the visual look of your brick mold (Representation), it's time to decide **where** these bricks connect to each other.  
That's where **Ports** come in — the snap points that define where a Brick can attach 🧲

---

#### 🧩 What Do You Need to Define a Port?

In the Semio Grasshopper plugin, each Port is defined with three main inputs:

- **A Port ID** 🏷️ (Id)  
  The name of the Port — a label used to define connections, such as `"n"`, `"bottom"`, or `"hingePoint"`.

- **A Point** 📍 (Pt)  
  The exact location where the connection happens — like the stud or socket on a LEGO brick.  
  You place it carefully on the surface of your geometry.

- **A Vector** ➡️ (Dr)  
  The direction the Port faces — like saying “this side connects outward.”  
  It’s important for aligning pieces when snapping.

---

#### 🏷️ Port ID (Id)

A **Port ID** is the label you give to each Port.  
This naming is important — because later, when you make connections, you'll say things like:

> "Connect Piece A's `top` Port to Piece B's `bottom` Port."

You can choose any naming system — as long as it makes sense in your design logic.  
In this example, we use:

- `n`, `s`, `e`, `w` — standing for **north, south, east, and west** 🧭

In your own project, you might use:

- `top`, `bottom`, `hinge`, `plug`, `outlet`, `windowDock` — or anything else 🔧

💡 **Tip:** Choose a consistent and meaningful naming system.  
It will make connecting components easier — and helps when working with AI or teammates.

---

#### 💡 Port Location (Pt)

(Add Image of the sketch with the ports)

When modeling Ports, it’s not just about where pieces touch — it’s about creating a clear, logical system that works across all Variants.

Here’s how to define your Ports effectively:

- 📍 **Choose stable, meaningful locations**  
  Place Ports in central or geometrically stable spots — like the center of a face, edge, corner, or endpoint.  
  Avoid placing them randomly across a surface. Symmetry often helps make your logic more reusable.

- ♻️ **Keep positions consistent across Variants**  
  Even if your pieces vary in length or size, try to place Ports in the same relative positions.  
  This keeps your connection logic intact across all Versions of a Type.

- 🎯 **Don’t worry about perfect alignment**  
  Semio allows you to adjust a Piece’s position and rotation *after* it snaps — so focus on logical placement, not exact fits.

---

There’s no strict rule for how many Ports to add — it depends on how much flexibility your system requires:

- 🔒 **Fewer Ports** → simpler, more controlled snapping  
- 🔓 **More Ports** → greater layout or orientation flexibility  
- 🧠 **Plan ahead** → add Ports you might need later, even if they’re not used right away

👉 *In our example, we use four Ports placed at the center of each edge of a four-sided profile

---

#### 💡 Port Direction (Dr)


Every Port needs a direction — a vector that tells Semio which way the connection faces.  
This is essential for aligning pieces correctly when snapping them together.

Here’s how to define direction effectively:

- ➡️ **Think of it as the “facing” of the Port**  
  The direction vector shows which way the Port is meant to connect — like saying, “this side points outward.”

- 🧭 **Use simple, readable vectors**  
  Stick to clean, orthogonal directions when possible (e.g. X, Y, or Z axes).  
  This keeps alignment predictable and easier to debug.

- ♻️ **Prioritize consistency over precision**  
  The pieces can still be moved or rotated after snapping, so vectors don’t have to be exact  
  but they **must be consistent** across all Variants to keep your logic reliable.

👉 *In our example, all edge Ports face outward — perpendicular to the face they sit on.*


---

Now you can see how the three inputs — Id, Pt, and Dr — work together to create Ports.
Each Port is defined by one entry from each list, so the lists must be the same length.
This ensures that every snapping point has a matching ID, position, and direction


  (Add port Image here Gh)
  (Image of Wireframe with points and Vectors in Rhino)

</li>

<li>

### 🧱 Assemble the Mold (Model Type)

After modeling all the parts of your brick mold —  
**Name**, **Variant**, **Ports**, and **Representation** —  
you plug them into the `Typ` component.

- 🏷️ **Name** → e.g. `"Profile"`  
- 🔢 **Variant** → e.g. `"4"`  
- 🧲 **Ports** → e.g. `n`, `s`, `e`, `w`  
- 🧊 **Representation** → the linked geometry


🎯 The result is a complete Type —
a smart, reusable building block, ready to be placed and connected in your Design.
It’s defined by the Name and Variant you assign — for example: Typ("profile", 4)


(Add Image of the Type component with the inputs)


---

</li>

</ol>
</Steps>



## 🧬 Mold Versions (Variants of Type)
→ Use the same mold to make bricks of different sizes

Now that you've created your base **Type**, it's time to generate **Variants** — based on the **unit count `n`** shown in the sketch.

Each Variant uses the **same mold**, just stretched or scaled.  
 Think of it like longer or shorter Lego bricks of the same kind 🧱🧱🧱  
 Since they follow the same design logic, we treat them as **Variants** of one **Type**, not separate Types.

#### 🔢 From the Sketch:

- **Variant 2** → 2 units long

- **Variant 4** → 4 units long

- **Variant 5** → 5 units long

---

#### 🔁 How to Model a Variant in semio

To model a Variant, you follow **the same steps** as creating a Type —  
 but with **two key differences**:

1. **Reuse** the original **Type name**

2. **Assign** a **unique Variant name** (e.g. the unit count `n`)

This tells semio:  
 ➡️ "Same mold, different size."

✅ Just like with Types, you have **three ways** to reference geometry:

- Direct from Grasshopper or Rhino Layer

- External file (recommended)

---

#### 💡 Advanced Tip: Use Clusters to Generate Variants

In Grasshopper, a smart way to manage **Variants** is by using a **Cluster** —  
 essentially a reusable mold-maker that builds each version of your LEGO brick 🧱

Since Variants are mostly identical and only differ by one or two inputs,  
 the Cluster helps you model everything once and repeat only what's necessary.

**Inside the Cluster:**  
 You define the full Type logic —

- Geometry generation
- Representation attachment (Model Representation)
- Port placement (Model Port)
- Type creation (Model Type)

**Outside the Cluster:**  
 You feed in only what changes:

- `n` → the unit count (e.g. 2, 4, 5), which controls the shape size 📏

- Variant name → In this Case it is also `n` 🏷️

This way, you can generate multiple Variants from the same Type mold —  
 without duplicating anything or cluttering your canvas.

✅ **Bonus:** Keeps your file organized and scalable — perfect for growing your Kit later on.

Showcase the three different methods :

Cluster without referencing

Cluster with referencing Files

Note > If the Shape would be different you would create a new type instead of Variants of the same type


---

