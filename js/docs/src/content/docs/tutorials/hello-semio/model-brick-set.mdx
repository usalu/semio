---
title: ğŸ§± Create Brick Set
description: All steps to break down, mold, and make variants of your model bricks.
sidebar:
  order: 2
---

import { Steps, Tabs, TabItem } from "@astrojs/starlight/components";



As mentioned earlier in **[Thinking in Semio](/think-in-semio/)**, a **Type** is like a **brick mold**.  

You're not just drawing geometry â€” you're designing a **template** that combines shape with meaningful design information.

---

##### ğŸ§© What Are the "Molds" in This Example?

Take a look at your sketch â€” you'll see five elements that follow the **same basic shape**, just stretched to different lengths.

Even though the final Design includes five Pieces, they're made from only **three distinct shapes**,  
with two of them used twice â€” giving us **three Variants of one Type**.

ğŸ§± Think of it like a LEGO brick that comes in 2-stud, 4-stud, and 5-stud versions â€” same shape logic, just scaled.

If the shape were completely different â€” like a triangle, window, or roof â€” that would count as a **new Type** altogether.


---

##### ğŸ”§ What Do We Need to Create These Molds?

When you think of a mold, the first thing that comes to mind is usually its **shape** â€” the geometry ğŸ§±âœï¸  
But in Semio, geometry is more than form â€” it serves as a **placeholder for meaning** ğŸ’¡

In traditional Grasshopper workflows, geometry is just raw data ğŸ§¬  
But in Semio, it becomes part of your **design language** ğŸ—£ï¸ğŸ¨ â€” a way to represent **intent**, not just surfaces ğŸ¯

For example:  
ğŸ‘‰ Instead of saying "connect point (x, y, z) to Brep edge 23"  
ğŸ‘‰ You say "connect the **door** to the **living room**"  
ğŸ‘‰ Or in LEGO terms: "**snap the window brick onto the top of the wall**" ğŸªŸğŸ§±

ğŸ”— The geometry still exists â€” but now it stands in for something more: **a role, a relationship, a meaning**.


---

## ğŸ§° Create a Brick Mold (Type - Ty)

Letâ€™s begin by modeling the mold shown in the sketch. 
This will serve as the base for generating its Variants.

Before we start building it, letâ€™s go over the essential elements that define a Type:

- **ğŸ·ï¸ Name** â†’ A unique name to identify your Type and reuse it in different designs.  
- **ğŸ§± Geometry (Representation)** â†’ The 3D shape attached to the Type. It gives the piece its visual form.  
- **ğŸ§² Connection Points (Ports)** â†’ The snap points where the piece connects to others in the system.

Letâ€™s take a look at the elements that make up a Type, and dive into modeling our first brick mold.

<Steps>
<ol>

<li>

### ğŸ·ï¸ Name Your Mold (Type Name - Na)

Giving clear and consistent names to elements in Semio **really pays off later** â€” especially when designing and making connections.  
As your project grows and you're working with many Types, Variants, and Pieces, meaningful names make everything easier to navigate and understand.

:::note
ğŸ“ Try to name things the way you would in a real project â€” clear, specific, and with purpose
:::


ğŸ‘‰ In our example, weâ€™ll name our Type **'Profile'**, since weâ€™re modeling Pieces based on custom wood shapes with a defined profile


---

</li>

<li>

### ğŸ§Š Attach Geometry (Representation â€“ Rp)


In Semio, when you give a Type its shape, you're adding a **Representation** ğŸ§±  
This isnâ€™t just visual geometry â€” itâ€™s a **layer of meaning** that stands in for a design element.

Think of it like snapping a shell onto a LEGO mold â€” now your brick has a visible form ğŸ‘€  
But that form isnâ€™t fixed. A Representation is more like a **costume** â€” it can be swapped at any time, as long as it fits the logic.

Just like architects might use a blocky volumes for urban models ğŸ™ï¸ or detailed profiles for close-ups ğŸªŸ,  
Semio lets you change the **look** without changing the **design logic** ğŸ”„  
Same brick, different shell â€” thatâ€™s the idea ğŸ’¡

---

##### ğŸ”§ Modeling Representation

Creating a Representation works in two simple steps:  
ğŸ§± First, you build the geometry â€” the actual shape of your brick  
ğŸ“ Then, you attach that shape to your Type to give it a visual form

Letâ€™s take a closer look at the brick mold in our example.  
Youâ€™ll notice that itâ€™s always the same shape ğŸ§± a rectangle cut at an angle âœ‚ï¸ just stretched into different sizes ğŸ“

Weâ€™ll use these two parameters to define its size:

- `W` â†’ the width of one brick unit  
- `n` â†’ the number of units in length

ğŸ§° Next, weâ€™ll dive into how to create and attach geometry to your brick mold.  
ğŸ§± In Semio, you can attach geometry to a Type in different ways â€” depending on what fits your workflow best.  
ğŸ‘€ Letâ€™s take a look at how that works in practice


<Tabs>

<TabItem label="File-Based Reference (ğŸ” Recommended)">



In Semio, Representations are typically referenced through **external geometry files** ğŸ—‚ï¸ â€” even when generated inside Grasshopper.  
This approach helps maintain **clean, modular workflows** ğŸ§¼ and supports flexible updates.

While the modeling process itself isnâ€™t the focus of this tutorial, the key takeaway is this:
youâ€™ll need to go through two simple steps to attach this geometry as a Representation


---

#### Step 1: ğŸ› ï¸ Geometry modeling 

Since our shape follows a clear logic ğŸ§ , we use a **parametric Grasshopper definition** to generate the geometry of the brick mold ğŸ§±  
This is useful because it lets us generate **all the different Variants** of this brick seen in the sketch, using a single logic controlled by the parameters `n` and `W`, which define the brickâ€™s length and width ğŸ“


![ğŸ“ Geometry Generation](/attach-geometry-crop.gif)


#### Step 2: ğŸ› ï¸ Geometry Export

After generating the geometry, we need to **export it as a `.glb` file** so it can be attached as a Representation.  
ğŸ’¾ Weâ€™ll use a simple workflow that automates this export â€” it can be placed directly after your geometry definition in Grasshopper.

The modeling of the geometry happens earlier in the Grasshopper definition ğŸ› ï¸  
here, weâ€™ll focus mainly on the **export logic**: how to turn that geometry into a file Semio can reference. ğŸ’¾

**The export workflow looks like this:**




{/* TODO: insert export geometry image */}

![ğŸ“¤ Export Geometry](/export-geometry.png)




- ğŸ“‚ **Set the Export Location**  
  A directory path is defined using the `Dir` and `Path` components.  
  This determines where the exported file will be saved.

- ğŸ“ **Build the File Name**  
  The file name is generated dynamically using `Concat`,  
  combining the Type name (e.g. `profile`) and the Variant (e.g. `2`) â†’ `profile_2.glb`

- ğŸ“‚ **Assemble the Full File Path**  
  A second `Concat` block merges the directory and file name:  
  `C:\Users\Users\Downloads\profile_2.glb`

- ğŸ“ **Prepare the Geometry**  
  - Convert or prepare the geometry in the desired format (e.g. Mesh)  
  - The `iGeo` component then writes the `.glb` file to disk

  Your file directory, where your Grasshopper definition is, should look like this:

  ![ğŸ“¤ Exported file](/file-export-Profile-2-.png)

 :::note
âš™ï¸ This method is ideal because it combines the familiar **parametric workflow** of Grasshopper with the **modular workflow** of Semio.  
ğŸ“¤ Every time a parameter is changed in the geometry generation, the corresponding file can be **automatically exported** and then **referenced** in the next step.
:::



---

#### Step 3: ğŸ”— Referencing the Exported File

The exported file name (e.g. `profile_2.glb`) is passed to the **`Ur` input** of the **Model Representation** component (`~Rep`).  
This tells Semio where to find the geometry file.

- The **`~Rep` (Model Representation)** component uses the `Ur` path â€” the file location â€” to create a Representation:  
  `Rep(model/gltf-binary)`

- This Representation is then connected in a later step to the **`Typ` (Model Type)** component.

{/* TODO: insert Referencing the Exported File image */}

![ğŸ“ Reference Geometry](/reference-geometry.png)

---

##### ğŸ” Why Use File-Based Referencing?

Even when working inside Grasshopper, Semio needs a **static snapshot** of your geometry â€”  
a file that captures the shape of your brick mold at that moment.

Hereâ€™s what that means:

- If your geometry is generated dynamically, it still needs to be **exported as a file**  
- Semio references that exported file â€” not the live Grasshopper definition

> ğŸ’¡ This approach keeps your geometry **modular and portable**, so it works seamlessly across Grasshopper and Semio Sketchpad  
> ğŸ§± It also enables working in **chunks** â€” letting you break large designs into smaller, manageable parts




</TabItem>

<TabItem label="Direct Reference">



Here are the 


</TabItem>

</Tabs>

##### ğŸ’¡ Tip: Choose the method that best fits your workflow.  
Want to go deeper into the pros and cons? Learn more here ğŸ”

---

#### ğŸ§ª Switching the Representation (Placeholder principle)


As introduced earlier, when you give a **Type** its shape in Semio, you're attaching a **Representation** â€”  
a piece of geometry that shows what the brick looks like visually ğŸ‘ï¸.  
But this geometry is more than just form: it acts as a **semantic placeholder** ğŸ§ .  
That means you can **change or swap** the Representation at any time **without breaking your design logic** ğŸ”

You can think of it like a **costume** for your Type ğŸ­  
The identity, name, and behavior stay the same â€” you're just changing how it looks on stage.

This flexibility is especially useful when working at **different levels of detail** across a project ğŸ§©

##### ğŸ¬ One Brick, various Representations

To illustrate this concept, we created **two geometry files** for the **same brick mold Type**:

---

<Tabs>

<TabItem label="ğŸ” Detailed Version">


This version uses the **fully detailed geometry** of the piece â€”  
a rectangle cut at an angle and extruded into a realistic wooden profile ğŸªµ
It includes every visible detail in 3D: full depth, edges, and joinery-ready shapes

![ğŸ“ Switch Representation](/Switch-Representation.png)
![ğŸ“ Filename](/Profile-2-detailed.png)


It reflects **real-world shape and fabrication detail**, making it ideal for:
- Joinery and production planning  
- Material-specific outputs  
- Detailed documentation and renders


{/* TODO: insert Detailed Version image */}

</TabItem>

<TabItem label="âš¡ Sheet Version">
This version is a **flat sheet simplification** â€”  
a single-surface geometry that represents the general size of the piece ğŸ“„.  
It captures only **one dimension** , and skips all 3D detail.

![ğŸ“ Switch Representation](/switch-representation-sheet.png)
![ğŸ“ Filename](/Profile-2-simplified.png)

Use this when:
- Only the 2D footprint is known  
- The full shape is not finalized yet  
- You need fast previews or early-stage coordination

</TabItem>

<TabItem label="âš¡ Block Version">

This version is a **bounding box simplification** â€”  
a simple block that approximates the pieceâ€™s volume ğŸ“¦.  
It includes **two dimensions** , but omits exact geometry.

![ğŸ“ Switch Representation](/switch-representation-Block.png)
![ğŸ“ Filename](/Profile-2-simplified.png)

Best for:
- Early-stage layouts and feasibility checks  
- Quick iterations and high-speed previews  
- Placeholder geometry before final detailing

{/* TODO: insert Simplified Version image */}
</TabItem>

</Tabs>




---

Even though these two Representations **look very different**, they both belong to the **same Type** âœ…. The **Name**, **Variant**, **Ports**, and **logic** stay exactly the same â€” only the appearance changes.

This means you can **design and assemble** everything using lightweight placeholders,  
then **swap in the detailed version** when you're ready for presentation, communication, or fabrication ğŸ§°.

> ğŸ’¡ In Semio, the Representation doesnâ€™t define the part â€” it simply **stands in for it**.  
> Like a LEGO minifig in different outfits ğŸ§‘â€ğŸš€ğŸ•µï¸ â€” it's still the same character underneath.

This separation of **logic and form** is what makes Semio workflows flexible, scalable, and robust, from early concept to detailed design to collaborative development ğŸ¤

</li>

<li>

### âš“ Add Snapping Points (Ports - Po)

Once you've modeled the visual look of your brick mold (Representation), it's time to decide **where** these bricks connect to each other.  
That's where **Ports** come in â€” the snap points that define where a Brick can attach ğŸ§²

---

##### ğŸ§© What Do You Need to Define a Port?

In the Semio Grasshopper plugin, each Port is defined with three main inputs:

- **A Port ID** ğŸ·ï¸ (Id)  
  The name of the Port â€” a label used to define connections, such as `"n"`, `"bottom"`, or `"hingePoint"`.

- **A Point** ğŸ“ (Pt)  
  The exact location where the connection happens â€” like the stud or socket on a LEGO brick.  
  You place it carefully on the surface of your geometry.

- **A Vector** â¡ï¸ (Dr)  
  The direction the Port faces â€” like saying â€œthis side connects outward.â€  
  Itâ€™s important for aligning pieces when snapping.


![ğŸ“ Ports](/model-port-alpha.png)
---



#### ğŸ’¡ Port Location (Pt)

(Add Image of the sketch with the ports)

When modeling Ports, itâ€™s not just about where pieces touch â€” itâ€™s about creating a clear, logical system that works across all Variants.

Hereâ€™s how to define your Ports effectively:

- ğŸ“ **Choose stable, meaningful locations**  
  Place Ports in central or geometrically stable spots â€” like the center of a face, edge, corner, or endpoint.  
  Avoid placing them randomly across a surface. Symmetry often helps make your logic more reusable.

- â™»ï¸ **Keep positions consistent across Variants**  
  Even if your pieces vary in length or size, try to place Ports in the same relative positions.  
  This keeps your connection logic intact across all Versions of a Type.

- ğŸ¯ **Donâ€™t worry about perfect alignment**  
  Semio allows you to adjust a Pieceâ€™s position and rotation *after* it snaps â€” so focus on logical placement, not exact fits.

---

Thereâ€™s no strict rule for how many Ports to add â€” it depends on how much flexibility your system requires:

- ğŸ”’ **Fewer Ports** â†’ simpler, more controlled snapping  
- ğŸ”“ **More Ports** â†’ greater layout or orientation flexibility  
- ğŸ§  **Plan ahead** â†’ add Ports you might need later, even if theyâ€™re not used right away

ğŸ‘‰ *In our example, we use four Ports placed at the center of each edge of a four-sided profile

---

#### ğŸ’¡ Port Direction (Dr)


Every Port needs a direction â€” a vector that tells Semio which way the connection faces.  
This is essential for aligning pieces correctly when snapping them together.

Hereâ€™s how to define direction effectively:

- â¡ï¸ **Think of it as the â€œfacingâ€ of the Port**  
  The direction vector shows which way the Port is meant to connect â€” like saying, â€œthis side points outward.â€

- ğŸ§­ **Use simple, readable vectors**  
  Stick to clean, orthogonal directions when possible (e.g. X, Y, or Z axes).  
  This keeps alignment predictable and easier to debug.

- â™»ï¸ **Prioritize consistency over precision**  
  The pieces can still be moved or rotated after snapping, so vectors donâ€™t have to be exact  
  but they **must be consistent** across all Variants to keep your logic reliable.

ğŸ‘‰ *In our example, all edge Ports face outward â€” perpendicular to the face they sit on.*


---
#### ğŸ·ï¸ Port ID (Id)

A **Port ID** is the label you give to each Port.  
This naming is important â€” because later, when you make connections, you'll say things like:

> "Connect Piece A's `top` Port to Piece B's `bottom` Port."

You can choose any naming system â€” as long as it makes sense in your design logic.  
In this example, we use:

- `n`, `s`, `e`, `w` â€” standing for **north, south, east, and west** ğŸ§­

In your own project, you might use:

- `top`, `bottom`, `hinge`, `plug`, `outlet`, `windowDock` â€” or anything else ğŸ”§

ğŸ’¡ **Tip:** Choose a consistent and meaningful naming system.  
It will make connecting components easier â€” and helps when working with AI or teammates.

---

Now you can see how the three inputs â€” Id, Pt, and Dr â€” work together to create Ports.
Each Port is defined by one entry from each list, so the lists must be the same length.
This ensures that every snapping point has a matching ID, position, and direction


  {/* TODO: insert port Image here Gh */}
  
  {/* TODO: insert Image of Wireframe with points and Vectors in Rhino */}

</li>

<li>

### ğŸ§± Assemble the Mold (Model Type)

After modeling all the parts of your brick mold â€”  
**Name**, **Variant**, **Ports**, and **Representation** â€”  
you plug them into the `Typ` component.

- ğŸ·ï¸ **Name** â†’ e.g. `"Profile"`  
- ğŸ”¢ **Variant** â†’ e.g. `"2"`  
- ğŸ§² **Ports** â†’ e.g. `n`, `s`, `e`, `w`  
- ğŸ§Š **Representation** â†’ the linked geometry

  {/* TODO: insert Image of Type component with the inputs */}
![ğŸ“ Model Type](/model-type.png)

![ğŸ“ Model Type](/model-type-geo.png)


  ğŸ¯ The result is a complete Type â€”
  a smart, reusable mold, ready to be casted into your Design.
  ğŸ§© The output `Typ("profile", 2)` means we're creating a Variant **named `2`** based on the `"profile"` mold ğŸ§± â€” a 2-unit-long brick ğŸ“



---

</li>

</ol>
</Steps>



## ğŸ§¬ Create Mold Versions (Variants of Type)

Now that you've created your base **Type**, it's time to generate **Variants** â€” based on the **unit count `n`** shown in the sketch.

Each Variant uses the **same mold**, just stretched or scaled.  
 Think of it like longer or shorter Lego bricks of the same kind ğŸ§±
 Since they follow the same design logic, we treat them as **Variants** of one **Type**, not separate Types.

- **Variant 2** â†’ 2 units long

- **Variant 4** â†’ 4 units long

- **Variant 5** â†’ 5 units long

---

#### ğŸ” Modeling a Variant

Modeling a **Variant** follows the **same steps** as creating a new Type â€”  
but with one key difference: you're referencing the **same mold**, just with a new configuration.

Hereâ€™s what changes:

1. **Reuse** the original **Type name** ğŸ·ï¸  
2. **Assign** a new **Variant name** (e.g. `n`, the unit count) ğŸ”¢

Youâ€™ll still go through the usual modeling steps:

1. Name your mold (**Type Name**)  
2. Attach geometry (**Model Representation**)  
3. Add Ports (**Model Port**)  
4. Set the Variant number  
5. Create the complete **Model Type**


âœ… Just like when modeling a Type, you define the Representation, Ports, and final Model Type â€” only the **Variant** changes.

---
{/* TODO: insert Image of model Type inside the cluster. Two images one for each variant */}



##### ğŸ’¡ Advanced Tip: Use Clusters to Generate Variants

In Grasshopper, a great way to handle multiple Variants is with a **Cluster** â€”  
a reusable mold-maker that generates each version of your LEGO brick ğŸ§±

Since most Variants share the same logic and differ by only one or two parameters, a Cluster helps you:

- Model the logic once  
- Generate all Variants efficiently  
- Keep your script clean and modular


![ğŸ“ Variant GIF](/Type-1-to-5-crop.gif)

<Tabs>

<TabItem label=" File-Based Geometry Reference">

**Inside the Cluster:**  

You define the full logic:

- Geometry generation & export   
- Modeling the Representation by linking the exported file  (Model Representation)
- Port placement (Model Port)
- Type creation (Model Type)

![ğŸ“ Cluster](/cluster-type-inside-ALpha.png)


**Outside the Cluster:**  

![ğŸ“ Cluster](/type-cluster-file-reference-Alpha.png)

![ğŸ“ Cluster](/file-export.png)

You feed in only what changes:

- `n` â†’ the unit count (e.g. 2, 4, 5) ğŸ“  
- Variant name â†’ (often also `n`) ğŸ·ï¸
- The Directory of the Grasshopper Definition
- Export toggle
 


</TabItem>

<TabItem label=" Direct Geometry Reference">

**Inside the Cluster:**  

![ğŸ“ Cluster](/cluster-type-inside-direct.rfrc.png)

You define the full logic:

- Geometry generation 
- Port placement (Model Port)
- Type creation (Model Type)

**Outside the Cluster:**  

![ğŸ“ Cluster](/type-cluster-direct-reference-Alpha.png)


You feed in only what changes:

- `n` â†’ the unit count (e.g. 2, 4, 5) ğŸ“  
- Variant name â†’ (often also `n`) ğŸ·ï¸




</TabItem>

</Tabs>




This way, you can generate many Variants from the same Type â€”  
without duplicating components or cluttering your canvas.

âœ… **Bonus:** Keeps your file organized and scalable â€” perfect for growing your Kit later on

---
{/* TODO: insert Gif of the cluster with the different variants */}