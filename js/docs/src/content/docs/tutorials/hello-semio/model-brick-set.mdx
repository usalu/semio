---
title: ğŸ§± Create Brick Molds
description: All steps to break down, mold, and make variants of your model bricks.
sidebar:
  order: 2
---

import { Steps, Tabs, TabItem } from "@astrojs/starlight/components";



As mentioned earlier in **[Thinking in Semio](/think-in-semio/)**,  
A **Type** is your brick mold ğŸ§± The Blueprint behind each Brick  
It defines not just the shape, but also the design meaning and connection logic ğŸ”§


---

##### ğŸ§© What Are the "Molds" in This Example?

Take a look at your sketch ğŸ‘€  
You'll see five elements that follow the **same basic shape**, just stretched to different lengths ğŸ“

Even though the final Design includes five Pieces, they're made from only **three distinct shapes**  
with two of them used twice â€” giving us **three Variants of one Type** ğŸ”¢

ğŸ§± Think of it like a LEGO brick that comes in 2-stud, 4-stud, and 5-stud versions â€”  
same shape logic, just scaled ğŸ“

If the shape were completely different â€” like a triangle, window, or roof â›°ï¸ğŸªŸğŸ   
That would count as a **new Type** altogether

---

##### ğŸ§  Modeling with Meaning


When you think of a mold, the first thing that comes to mind is usually its **shape** â€” the geometry ğŸ§±âœï¸  
But in Semio, the **mold** is what combines **shape** with **meaningful design information** ğŸ’¡

In traditional Grasshopper workflows, youâ€™re modeling with **raw data** â€” points, curves, and surfaces â€” without embedding **design intent** ğŸ§¬  
You build logic around it, but that logic stays detached â€” abstract, custom, and often fragile.

> In **Semio**, the mold connects geometry with design intent directly ğŸ§   
> You're not referencing arbitrary geometry â€” you're referencing **relationships**, **roles**, and **rules** ğŸ§©

For example:  
ğŸ‘‰ Instead of saying "connect point (x, y, z) to Brep edge 23"  
ğŸ‘‰ You say "connect the **door** to the **living room**" ğŸ›‹ï¸ğŸšª  
ğŸ‘‰ Or in LEGO terms: "ğŸªŸ **snap the window brick onto the top of the wall**" ğŸ§±

This is what gives Semio its strength â€” youâ€™re not just building shapes,  
youâ€™re building a **semantic system** that adapts, scales, and speaks your design language ğŸ¯ğŸ—£ï¸

---

## ğŸ§° Create a Brick Mold ([Type](/think-in-semio/#type) â€“ Ty)

Letâ€™s begin by modeling the mold shown in the sketch  
This will serve as the base for generating its **Variants** ğŸ§©

![ğŸ“¤ sketch drawing](/sketch-drawing-mold.png)

Before we start building, letâ€™s go over the essential elements that define a **Type** ğŸ§±:

- ğŸ·ï¸ **Name** â†’ A unique name to identify your Type and reuse it in different designs  
- ğŸ§± **Geometry (Representation)** â†’ The 3D shape attached to the Type â€” it gives the piece its visual form âœ¨  
- ğŸ§² **Connection Points (Ports)** â†’ The snap points where the piece connects to others in the system ğŸ”—

Now letâ€™s take a closer look at how these elements come together â€” and start modeling our first **brick mold** ğŸ› ï¸



<Steps>
<ol>

<li>

### ğŸ·ï¸ Name Your Mold ([Type](/think-in-semio/#type) Name - Na)

Clear, consistent names in Semio make everything easier down the line âœ…  
Especially when your project grows and you're working with many **Types**, **Variants**, and **Pieces** ğŸ”„

Good names help you:

- ğŸ§­ **Navigate** your system  
- ğŸ” **Understand** relationships  
- ğŸ”— **Make connections** that are easy to track

:::note
Use names you'd use in a real project â€” specific, descriptive, and purposeful ğŸ“ 
:::

ğŸ‘‰ In our example, weâ€™ll name our Type **"Profile"**  
because the shape we're modeling is based on a **standard manufactured wood profile** ğŸªµ


---

</li>

<li>

### ğŸ§Š Attach Geometry (Representation â€“ Rp)

In Semio, the process of adding geometry to a Type is called **modeling its Representation** ğŸ› ï¸
A **Representation** is anything that visually or symbolically **represents a Type** ğŸ§±
It helps you **see or recognize** the Type â€” without defining its logic or behavior ğŸ§ 

In most cases, this will be a **3D geometry**, like in our example
But it can also be:

- A 2D drawing or diagram âœï¸  
- A symbolic icon or block ğŸ”³  
- A label, file, or reference ğŸ”–

ğŸ’¡ Because Representations are separate from the logic of the system, theyâ€™re fully flexible:

- You can start modeling your system without one ğŸš§  
- You can add or update it later ğŸ› ï¸  
- You can switch between levels of detail depending on the design phase ğŸ”

In this example, weâ€™ll use a **simple 3D shape** to represent our brick molds we need to create ğŸ§©


---

##### ğŸ”§ Modeling Representation

There are two simple steps to create a Representation:


- ğŸ› ï¸ **Step 1 â€” Build the geometry**  
  Create the actual shape of your brick â€” the form you want to use in your design

- ğŸ“ **Step 2 â€” Attach it to the Type**  
  This links the shape to your Type, making it visible and placeable in the design space

---

Letâ€™s take a closer look at the **brick mold** in our example ğŸ‘€  
It always follows the **same basic shape** ğŸ§±  
A **rectangle thatâ€™s cut at an angle** âœ‚ï¸ â€” just repeated in different lengths ğŸ“  

As we saw in the sketch, its size is described using **two parameters**:

- `W` â†’ the width of one brick unit  
- `n` â†’ the number of units in length

---

In **Semio**, you can attach geometry to a Type in different ways ğŸ”„  
You can pick the method that best fits your **workflow or tool**.  

Letâ€™s take a look at how that works in practice ğŸ‘‡ 



<Tabs>

<TabItem label="File-Based Reference (ğŸ” Recommended)">



In **Semio**, Representations are typically referenced through **external geometry files** ğŸ—‚ï¸  
â€” even when those files are generated inside **Grasshopper**

This approach keeps your workflow **clean**, **modular**, and **easy to update** ğŸ§¼  
It also makes your design system more **reusable** and **scalable** ğŸ”

While the modeling process itself isnâ€™t the focus of this tutorial,  
hereâ€™s the key takeaway:  
Youâ€™ll need to follow **three simple steps** to attach your geometry as a **Representation** ğŸ§±

---

#### ğŸ› ï¸ Geometry Modeling

Since our shape follows a clear logic ğŸ§   
we use a **parametric Grasshopper definition** to generate the geometry of the brick mold ğŸ§±  

This is useful because it lets us generate **all the different Variants** of this brick seen in the sketch  
using a single logic controlled by the parameters `n` and `W`  
which define the brickâ€™s length and width ğŸ“

![ğŸ“ Geometry Generation](/attach-geometry-crop.gif)

---

#### ğŸ’¾ Geometry Export

After generating the geometry,  
we need to **export it as a `.glb` file** so it can be attached as a **Representation** ğŸ’¾

Weâ€™ll use a **simple workflow** that automates this export ğŸ¦¾  
You can place it **directly after** your geometry generation step in Grasshopper ğŸ¦—

---

ğŸ” The Export Workflow Looks Like This:

![ğŸ“¤ Export Geometry](/export-geometry.png)

---

#### ğŸ—‚ï¸ Set the Export Location  
Use the `Dir` and `Path` components to define the directory path  
This determines where the exported file will be saved

#### ğŸ“ Build the File Name  
Use `Concat` to generate the file name dynamically  
Combine the Type name and Variant (e.g. `profile` + `2`) â†’ `profile_2.glb`

#### ğŸ§© Assemble the Full File Path  
Another `Concat` merges directory + file name:  
`C:\Users\Users\Downloads\profile_2.glb`

#### ğŸ“ Prepare the Geometry

> ğŸ› ï¸ You've already modeled the geometry earlier in your Grasshopper definition.  
> Now it's time to **export** it â€” so Semio can use it as a **referenced Representation** ğŸ’¾

- âœ… Convert the geometry into the required format (e.g. **Mesh** for `.glb`)
- ğŸ“¤ Pass it into the `iGeo` component to export it as a `.glb` file  


Your file directory should now look like this:

![ğŸ“¤ Exported file](/file-export-Profile-2-.png)

---

:::note
âš™ï¸ This method combines the **parametric power of Grasshopper** with the **modular logic of Semio**  
ğŸ“¤ Every time a parameter changes, the file can be **re-exported automatically** â€”  
ready to be referenced in the next step  
:::


---

#### ğŸ”— Referencing the Exported File

The exported file (e.g. `profile_2.glb`) is linked to the **`Ur` input** of the **Model Representation** component (`~Rep`)  
This tells Semio **where to find the geometry** that represents your Type.

- ğŸ§© The **`~Rep` (Model Representation)** component takes the `Ur` file path and creates a Representation:  
  â†’ `Rep(model/gltf-binary)`

- ğŸ”— This Representation is later connected to the **`Typ` (Model Type)** component â€”  
  so that your Type is linked to its visual form

![ğŸ“ Reference Geometry](/reference-geometry.png)

---

### ğŸ” Why Use File-Based Referencing?

Even inside Grasshopper, Semio requires a **file-based snapshot** of your geometry â€”  
a static file that captures what your brick mold looks like at a specific moment.

Hereâ€™s why that matters:

- âš™ï¸ If your geometry is dynamic or parametric, it still needs to be **exported to a file**  
- ğŸ”— Semio connects to that file â€” not the live Grasshopper preview

> ğŸ’¡ This keeps geometry **modular**, **portable**, and easy to reuse  
> ğŸ§± It also supports **chunking** â€” breaking down large designs into smaller, manageable parts  
> ğŸŒ And it allows smooth transition between **Grasshopper** and **Semio Sketchpad**





</TabItem>

<TabItem label="Direct Reference">



You donâ€™t always need to embed geometry directly into a Type ğŸ§±
In some cases, you can skip integration and reference the geometry directly in Grasshopper instead ğŸ›ï¸

Just pass the geometry â€” either as a Geometry ğŸ§Š or Object ğŸ§© â€” straight into the Preview Design component ğŸ‘€
This lets you visualize your Design using custom shapes without embedding them into the Typeâ€™s definition ğŸ”

ğŸ‘‰ Weâ€™ll explore this option in a later step.
âš ï¸ Just note: this method is for visualization only â€” the geometry wonâ€™t be part of the mold itself

</TabItem>

</Tabs>


---

#### ğŸ§ª Switching the Representation 

As introduced earlier, when you give a **Type** its shape in Semio, you're attaching a **Representation** â€”  
a piece of geometry that shows what the brick looks like visually ğŸ‘ï¸

But this geometry isnâ€™t fixed â€” it acts more like a **placeholder** ğŸ§   
That means you can **change or swap** the Representation at any time **without breaking your design logic** ğŸ”

You can think of it like a **costume** for your Type ğŸ­  
The name, role, and connections stay the same â€” you're just changing how it looks on stage ğŸ¬

This flexibility is especially useful when working across **different levels of detail** in a project ğŸ§©

Just like architects might use **blocky volumes** for urban massing ğŸ™ï¸  
and **detailed profiles** for close-ups or fabrication ğŸªŸ  
Semio lets you swap the **look** without changing the **logic** ğŸ”„  
Same brick â€” different shell ğŸ’¡

##### ğŸ¬ One Brick, various Representations

To illustrate this concept, we created **two geometry files** for the **same brick mold Type**:

---

<Tabs>

<TabItem label="ğŸ” Detailed Version">

This version uses the **fully detailed geometry** of the piece   
a rectangle cut at an angle and extruded into a realistic wooden profile ğŸªµ  
It includes every visible detail in 3D: full depth, edges, and joinery-ready shapes âœ‚ï¸

![ğŸ“ Switch Representation](/Switch-Representation.png)  
![ğŸ“ Filename](/Profile-2-detailed.png)

Best for:
- ğŸªš Joinery and production planning  
- ğŸ“ Material-specific outputs  
- ğŸ–¼ï¸ Detailed documentation and renders  

</TabItem>

<TabItem label="ğŸ“„ Sheet Version">

This version is a **flat sheet simplification**  
a single-surface geometry that represents the general size of the piece ğŸ“  
It captures only **one dimension** and skips all 3D detail

![ğŸ“ Switch Representation](/switch-representation-sheet.png)  
![ğŸ“ Filename](/Profile-2-simplified.png)

Use this when:
- ğŸ“ Only the 2D footprint is known  
- âœï¸ The full shape is not finalized yet  
- âš¡ You need fast previews or early-stage coordination  

</TabItem>

<TabItem label="ğŸ“¦ Block Version">

This version is a **bounding box simplification**   
a simple block that approximates the pieceâ€™s volume ğŸ§±  
It includes **two dimensions** but omits exact geometry

![ğŸ“ Switch Representation](/switch-representation-Block.png)  
![ğŸ“ Filename](/Profile-2-simplified.png)

Best for:
- ğŸ§ª Early-stage layouts and feasibility checks  
- âš™ï¸ Quick iterations and high-speed previews  
- ğŸ§Š Placeholder geometry before final detailing  

</TabItem>

</Tabs>




---

Even though these two Representations **look very different**, they both belong to the **same Type** âœ…. The **Name**, **Variant**, **Ports**, and **logic** stay exactly the same â€” only the appearance changes

This means you can **design and assemble** everything using lightweight placeholders,  
then **swap in the detailed version** when you're ready for presentation, communication, or fabrication ğŸ§°

This separation of **logic and form** is what makes Semio workflows flexible, scalable, and robust, from early concept to detailed design to collaborative development ğŸ¤

</li>

<li>

### âš“ Add Snapping Points ([Ports](/think-in-semio/#port) - Po)

Once you've modeled the visual look of your brick mold (Representation), it's time to decide **where** these bricks connect to each other  
That's where **Ports** come in â€” the snap points that define where a Brick can attach ğŸ§²

---

##### ğŸ§© What Do You Need to Define a Port?

In the Semio Grasshopper plugin, each Port is defined with three main inputs:

- **A Port ID** ğŸ·ï¸ (Id)  
  The name of the Port â€” a label used to define connections, such as `"n"`, `"bottom"`, or `"hingePoint"`

- **A Point** ğŸ“ (Pt)  
  The exact location where the connection happens â€” like the stud or socket on a LEGO brick.  
  You place it carefully on the surface of your geometry

- **A Vector** â¡ï¸ (Dr)  
  The direction the Port faces â€” like saying â€œthis side connects outwardâ€  
  Itâ€™s important for aligning pieces when snapping


![ğŸ“ Ports](/model-port-alpha.png)

---



#### ğŸ’¡ Port Location (Pt)

(Add Image of the sketch with the ports)

When modeling Ports, itâ€™s not just about where pieces touch â€” itâ€™s about creating a clear, logical system that works across all Variants.

Hereâ€™s how to define your Ports effectively:

- ğŸ“ **Choose stable, meaningful locations**  
  Place Ports in central or geometrically stable spots â€” like the center of a face, edge, corner, or endpoint.  
  Avoid placing them randomly across a surface. Symmetry often helps make your logic more reusable

- â™»ï¸ **Keep positions consistent across Variants**  
  Even if your pieces vary in length or size, try to place Ports in the same relative positions  
  This keeps your connection logic intact across all Versions of a Type

- ğŸ¯ **Donâ€™t worry about perfect alignment**  
  Semio allows you to adjust a Pieceâ€™s position and rotation *after* it snaps â€” so focus on logical placement, not exact fits.

---

Thereâ€™s no strict rule for how many Ports to add â€” it depends on how much flexibility your system requires:

- ğŸ”’ **Fewer Ports** â†’ simpler, more controlled snapping  
- ğŸ”“ **More Ports** â†’ greater layout or orientation flexibility  
- ğŸ§  **Plan ahead** â†’ add Ports you might need later, even if theyâ€™re not used right away


ğŸ‘‰ *In our example, we use four Ports placed at the center of each edge of a four-sided profile

---

#### ğŸ’¡ Port Direction (Dr)


Every Port needs a direction â€” a vector that tells Semio which way the connection faces  
This is essential for aligning pieces correctly when snapping them together

Hereâ€™s how to define direction effectively:

- â¡ï¸ **Think of it as the â€œfacingâ€ of the Port**  
  The direction vector shows which way the Port is meant to connect â€” like saying, â€œthis side points outwardâ€

- ğŸ§­ **Use simple, readable vectors**  
  Stick to clean, orthogonal directions when possible (e.g. X, Y, or Z axes).  
  This keeps alignment predictable and easier to debug.

- â™»ï¸ **Prioritize consistency over precision**  
  The pieces can still be moved or rotated after snapping, so vectors donâ€™t have to be exact  
  but they **must be consistent** across all Variants to keep your logic reliable

ğŸ‘‰ *In our example, all edge Ports face outward â€” perpendicular to the face they sit on*


---
#### ğŸ·ï¸ Port ID (Id)

A **Port ID** is the label you give to each Port  
This naming is important â€” because later, when you make connections, you'll say things like:

> "Connect Piece A's `top` Port to Piece B's `bottom` Port"

You can choose any naming system â€” as long as it makes sense in your design logic  
In this example, we use:

- `n`, `s`, `e`, `w` â€” standing for **north, south, east, and west** ğŸ§­

In your own project, you might use:

- `top`, `bottom`, `hinge`, `plug`, `outlet`, `windowDock` â€” or anything else ğŸ”§

ğŸ’¡ **Tip:** Choose a consistent and meaningful naming system.  
It will make connecting components easier â€” and helps when working with AI or teammates.

---

Now you can see how the three inputs â€” Id, Pt, and Dr â€” work together to create Ports.
Each Port is defined by one entry from each list, so the lists must be the same length.
This ensures that every snapping point has a matching ID, position, and direction


  {/* TODO: insert port Image here Gh */}
  
  {/* TODO: insert Image of Wireframe with points and Vectors in Rhino */}

</li>

<li>

### ğŸ§± Assemble the Mold (Model [Type](/think-in-semio/#type))

After modeling all the parts of your brick mold â€”  
**Name**, **Variant**, **Ports**, and **Representation** â€”  
you plug them into the `Typ` component.

- ğŸ·ï¸ **Name** â†’ e.g. `"Profile"`  
- ğŸ”¢ **Variant** â†’ e.g. `"2"`  
- ğŸ§² **Ports** â†’ e.g. `n`, `s`, `e`, `w`  
- ğŸ§Š **Representation** â†’ the linked geometry

  {/* TODO: insert Image of Type component with the inputs */}
![ğŸ“ Model Type](/model-type.png)

![ğŸ“ Model Type](/model-type-geo.png)


  ğŸ¯ The result is a complete Type â€”
  a smart, reusable mold, ready to be casted into your Design
  ğŸ§© The output `Typ("profile", 2)` means we're creating a Variant **named `2`** based on the `"profile"` mold ğŸ§± â€” a 2-unit-long brick ğŸ“



---

</li>

</ol>
</Steps>



## ğŸ§¬ Create Mold Versions (Variants of [Type](/think-in-semio/#type))


![ğŸ“¤ sketch drawing](/sketch-drawing-variant.png)


Now that you've created your base **Type**, it's time to generate **Variants** â€” based on the **unit count `n`** shown in the sketch

Each Variant uses the **same mold**, just stretched or scaled.  
 Think of it like longer or shorter Lego bricks of the same kind ğŸ§±
 Since they follow the same design logic, we treat them as **Variants** of one **Type**, not separate Types.

- **Variant 2** â†’ 2 units long

- **Variant 4** â†’ 4 units long

- **Variant 5** â†’ 5 units long

---

#### ğŸ” Modeling a Variant

Modeling a **Variant** follows the **same steps** as creating a new Type â€”  
but with one key difference: you're referencing the **same mold**, just with a new configuration

Hereâ€™s what changes:

1. **Reuse** the original **Type name** ğŸ·ï¸  
2. **Assign** a new **Variant name** (e.g. `n`, the unit count) ğŸ”¢

Youâ€™ll still go through the usual modeling steps:

1. Name your mold (**Type Name**)  
2. Attach geometry (**Model Representation**)  
3. Add Ports (**Model Port**)  
4. Set the Variant number  
5. Create the complete **Model Type**

:::note
ğŸ§­ Keeping Port positions **consistent across Variants** makes your Types easier to reuse, align, and assemble smoothly
:::

âœ… Just like when modeling a Type, you define the Representation, Ports, and final Model Type â€” only the **Variant** changes

---



##### ğŸ’¡ Advanced Tip: Use Clusters to Generate Variants

In Grasshopper, a great way to handle multiple Variants is with a **Cluster** â€”  
a reusable mold-maker that generates each version of your LEGO brick ğŸ§±

Since most Variants share the same logic and differ by only one or two parameters, a Cluster helps you:

- Model the logic once  
- Generate all Variants efficiently  
- Keep your script clean and modular


![ğŸ“ Variant GIF](/Type-1-to-5-crop.gif)

<Tabs>

<TabItem label=" File-Based Geometry Reference">

**Inside the Cluster:**  

You define the full logic:

- Geometry generation & export   
- Modeling the Representation by linking the exported file  (Model Representation)
- Port placement (Model Port)
- Type creation (Model Type)

![ğŸ“ Cluster](/cluster-type-inside-ALpha.png)


**Outside the Cluster:**  

![ğŸ“ Cluster](/type-cluster-file-reference-Alpha.png)

![ğŸ“ Cluster](/file-export.png)

You feed in only what changes:

- `n` â†’ the unit count (e.g. 2, 4, 5) ğŸ“  
- Variant name â†’ (often also `n`) ğŸ·ï¸
- The Directory of the Grasshopper Definition
- Export toggle
 


</TabItem>

<TabItem label=" Direct Geometry Reference">

**Inside the Cluster:**  

![ğŸ“ Cluster](/cluster-type-inside-direct.rfrc.png)

You define the full logic:

- Geometry generation 
- Port placement (Model Port)
- Type creation (Model Type)

**Outside the Cluster:**  

![ğŸ“ Cluster](/type-cluster-direct-reference-Alpha.png)


You feed in only what changes:

- `n` â†’ the unit count (e.g. 2, 4, 5) ğŸ“  
- Variant name â†’ (often also `n`) ğŸ·ï¸




</TabItem>

</Tabs>




This way, you can generate many Variants from the same Type â€”  
without duplicating components or cluttering your canvas

âœ… **Bonus:** Keeps your file organized and scalable â€” perfect for growing your Kit later on

---
{/* TODO: insert Gif of the cluster with the different variants */}