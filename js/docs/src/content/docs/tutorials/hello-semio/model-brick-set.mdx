---
title: ğŸ§± Create Brick Set
description: All steps to break down, mold, and make variants of your model bricks.
sidebar:
  order: 2
---

import { Steps, Tabs, TabItem } from "@astrojs/starlight/components";



As mentioned earlier in **[Thinking in Semio](/think-in-semio/)**, a **Type** is like a **brick mold**.  

You're not just drawing geometry â€” you're designing a **template** that combines shape with meaningful design information.

---

#### ğŸ§© What Are the "Molds" in This Example?

Take a look at your sketch â€” you'll see five elements that follow the **same basic shape**, just stretched to different lengths.

Even though the final Design includes five Pieces, they're made from only **three distinct shapes**,  
with two of them used twice â€” giving us **three Variants of one Type**.

ğŸ§± Think of it like a LEGO brick that comes in 2-stud, 4-stud, and 5-stud versions â€” same shape logic, just scaled.

If the shape were completely different â€” like a triangle, window, or roof â€” that would count as a **new Type** altogether.


---

#### ğŸ”§ What Do We Need to Create These Molds?

When you think of a mold, the first thing that comes to mind is usually its **shape** â€” the geometry ğŸ§±âœï¸  
But in Semio, geometry is more than form â€” it serves as a **placeholder for meaning** ğŸ’¡

In traditional Grasshopper workflows, geometry is just raw data ğŸ§¬  
But in Semio, it becomes part of your **design language** ğŸ—£ï¸ğŸ¨ â€” a way to represent **intent**, not just surfaces ğŸ¯

For example:  
ğŸ‘‰ Instead of saying "connect point (x, y, z) to Brep edge 23"  
ğŸ‘‰ You say "connect the **door** to the **living room**"  
ğŸ‘‰ Or in LEGO terms: "**snap the window brick onto the top of the wall**" ğŸªŸğŸ§±

ğŸ”— The geometry still exists â€” but now it stands in for something more: **a role, a relationship, a meaning**.


---

## ğŸ§° What makes a Brick Mold (Type)?

Let's go over the essential ingredients for creating a Type:

- **ğŸ·ï¸ Name** â†’ A unique name to identify your Type and reuse it in different designs.  
- **ğŸ§± Geometry (Representation)** â†’ The 3D shape attached to the Type. It gives the piece its visual form.  
- **ğŸ§² Connection Points (Ports)** â†’ The snap points where the piece connects to others in the system.

Letâ€™s take a look at the elements that make up a Type, and dive into modeling our first brick mold.

<Steps>
<ol>

<li>

### ğŸ·ï¸ Name Your Mold (Type Name)

Giving clear and consistent names to elements in Semio **really pays off later** â€” especially when designing and making connections.  
As your project grows and you're working with many Types, Variants, and Pieces, meaningful names make everything easier to navigate and understand.

ğŸ“ Try to name things the way you would in a real project â€” clear, specific, and with purpose.

---

</li>

<li>

### ğŸ§Š Attach Geometry (Model Representation)

In Semio, when you give a Type its shape, you're adding a **Representation** ğŸ§±  
This isnâ€™t just visual geometry â€” itâ€™s a **layer of meaning** that stands in for a design element.

Think of it like snapping a shell onto a LEGO mold â€” now your brick has a visible form ğŸ‘€  
But that form isnâ€™t fixed. A Representation is more like a **costume** â€” it can be swapped at any time, as long as it fits the logic.

Just like architects might use a blocky mass for urban models ğŸ™ï¸ or detailed profiles for close-ups ğŸªŸ,  
Semio lets you change the **look** without changing the **design logic** ğŸ”„  
Same brick, different shell â€” thatâ€™s the idea ğŸ’¡

---

#### ğŸ”§ How to Model a Representation

To add a Representation, you first need to create the actual **geometry** â€” the body of your building block.  
In Semio, you can attach this geometry to a Type in **two main ways**, depending on your workflow:

<Tabs>

<TabItem label="Direct Reference">

Use a parametric definition in Grasshopper to generate the shape.  
In our example, the geometry is a rectangle, cut at an angle and extruded into a wooden profile.  
The length is defined by two parameters:

- `W` = unit width  
- `n` = number of segments

</TabItem>

<TabItem label="File-Based Reference (ğŸ” Recommended)">

Model the shape externally (e.g. in Rhino), then attach it to your Type by referencing a named layer.

</TabItem>

</Tabs>

##### ğŸ’¡ Tip: Choose the method that best fits your workflow.  
Want to go deeper into the pros and cons? Learn more here ğŸ”

---

#### ğŸ§ª Representation as a Placeholder

Representations can be swapped â€” theyâ€™re just one way to **visualize** a design, not define it.  
That means you can use **different versions** of the same Type depending on your needs:

<Tabs>

<TabItem label="ğŸ” Detailed Version">

Use a high-detail Representation with features like joints, profiles, or textures â€” ideal for fabrication or close-up studies.

</TabItem>

<TabItem label="âš¡ Simplified Version">

Use a simplified shape â€” fast to render and easier to work with at larger scales.

</TabItem>

</Tabs>

This flexibility helps keep your model lightweight while preserving the underlying logic.


### âš“ Add Snapping Points (Model Ports)

Once you've modeled the visual look of your brick mold (Representation), it's time to decide **where** these bricks connect to each other.  
That's where **Ports** come in â€” the snap points that define where a Brick can attach ğŸ§²

---

#### ğŸ§© What Do You Need to Define a Port?

In the Semio Grasshopper plugin, each Port is defined with three main inputs:

- **A Port ID** ğŸ·ï¸  
  The name of the Port â€” a label used to define connections, such as `"n"`, `"bottom"`, or `"hingePoint"`.

- **A Point** ğŸ“  
  The exact location where the connection happens â€” like the stud or socket on a LEGO brick.  
  You place it carefully on the surface of your geometry.

- **A Vector** â¡ï¸  
  The direction the Port faces â€” like saying â€œthis side connects outward.â€  
  Itâ€™s important for aligning pieces when snapping.

---

#### ğŸ·ï¸ Port ID

A **Port ID** is the label you give to each Port.  
This naming is important â€” because later, when you make connections, you'll say things like:

> "Connect Piece A's `top` Port to Piece B's `bottom` Port."

You can choose any naming system â€” as long as it makes sense in your design logic.  
In this example, we use:

- `n`, `s`, `e`, `w` â€” standing for **north, south, east, and west** ğŸ§­

In your own project, you might use:

- `top`, `bottom`, `hinge`, `plug`, `outlet`, `windowDock` â€” or anything else ğŸ”§

ğŸ’¡ **Tip:** Choose a consistent and meaningful naming system.  
It will make connecting components easier â€” and helps when working with AI or teammates.

---

#### ğŸ’¡ Port Location

Don't just place Ports where pieces touch â€” place them where they make sense **logically and consistently** across all Variants.

Hereâ€™s how to decide:

- ğŸ“ **Place Ports in central or stable locations**  
  (e.g. the center of a face, edge, corner, or endpoint â€” not just randomly on a surface.
Symmetry is often helpful for keeping your logic clean and reusable.)

- â™»ï¸ **Use the same Port positions for all Variants of a Type**  
  This keeps your snapping logic reusable, even if the shapes vary

- ğŸ¯ **Don't worry about perfect alignment**  
  Semio lets you adjust a Piece's position and rotation *after* it snaps

---

#### ğŸ’¡ Port Count

Thereâ€™s no fixed number â€” it depends on how much flexibility you want in your design system.

- ğŸ”’ **Use fewer Ports** for simple, strict snapping  
- ğŸ”“ **Add more Ports** if you want layout or orientation flexibility  
- ğŸ§  **Plan ahead:** Add Ports you might need later, even if you don't use them right away

---

</li>

<li>

### ğŸ§± Assemble the Mold (Model Type)

After modeling all the parts of your brick mold â€”  
**Name**, **Variant**, **Ports**, and **Representation** â€”  
you plug them into the `Typ` component.

- ğŸ·ï¸ **Name** â†’ e.g. `"Profile"`  
- ğŸ”¢ **Variant** â†’ e.g. `2`  
- ğŸ§² **Ports** â†’ e.g. `n`, `s`, `e`, `w`  
- ğŸ§Š **Representation** â†’ the linked geometry

ğŸ¯ The result is a complete **Type** â€”  
a smart, reusable building block ready to be placed and connected in your Design.

Think of it as snapping all the mold info together â€” and voilÃ , you've made your custom LEGO brick ğŸ”§ğŸ§±

---

</li>

</ol>
</Steps>



## ğŸ§¬ Mold Versions (Variants of Type)
â†’ Use the same mold to make bricks of different sizes

Now that you've created your base **Type**, it's time to generate **Variants** â€” based on the **unit count `n`** shown in the sketch.

Each Variant uses the **same mold**, just stretched or scaled.  
 Think of it like longer or shorter Lego bricks of the same kind ğŸ§±ğŸ§±ğŸ§±  
 Since they follow the same design logic, we treat them as **Variants** of one **Type**, not separate Types.

#### ğŸ”¢ From the Sketch:

- **Variant 2** â†’ 2 units long

- **Variant 4** â†’ 4 units long

- **Variant 5** â†’ 5 units long

---

#### ğŸ” How to Model a Variant in semio

To model a Variant, you follow **the same steps** as creating a Type â€”  
 but with **two key differences**:

1. **Reuse** the original **Type name**

2. **Assign** a **unique Variant name** (e.g. the unit count `n`)

This tells semio:  
 â¡ï¸ "Same mold, different size."

âœ… Just like with Types, you have **three ways** to reference geometry:

- Direct from Grasshopper or Rhino Layer

- External file (recommended)

---

#### ğŸ’¡ Advanced Tip: Use Clusters to Generate Variants

In Grasshopper, a smart way to manage **Variants** is by using a **Cluster** â€”  
 essentially a reusable mold-maker that builds each version of your LEGO brick ğŸ§±

Since Variants are mostly identical and only differ by one or two inputs,  
 the Cluster helps you model everything once and repeat only what's necessary.

**Inside the Cluster:**  
 You define the full Type logic â€”

- Geometry generation
- Representation attachment (Model Representation)
- Port placement (Model Port)
- Type creation (Model Type)

**Outside the Cluster:**  
 You feed in only what changes:

- `n` â†’ the unit count (e.g. 2, 4, 5), which controls the shape size ğŸ“

- Variant name â†’ In this Case it is also `n` ğŸ·ï¸

This way, you can generate multiple Variants from the same Type mold â€”  
 without duplicating anything or cluttering your canvas.

âœ… **Bonus:** Keeps your file organized and scalable â€” perfect for growing your Kit later on.

Showcase the three different methods :

Cluster without referencing

Cluster with referencing Files

Note > If the Shape would be different you would create a new type instead of Variants of the same type


---

