---
title: 🧱 Create Brick Set
description: All steps to break down, mold, and make variants of your model bricks.
sidebar:
  order: 2
---

import { Steps, Tabs, TabItem } from "@astrojs/starlight/components";


## 🧰 Create Brick Mold (Type)

As mentioned earlier in **Thinking in Semio**, a **Type** is like a **brick mold**.  
You're not just drawing geometry — you're designing a **template** that combines shape with meaningful design information.

---

##### 🧩 What Are the "Molds" in This Example?

Each of the five elements in your sketch is a **variant** of the **same Type** —  
meaning they all share the same shape logic but vary in size.

So while you see five Pieces in the final Design, they're made up of **three unique shapes**,  
with two of them repeated once — making **three Variants of one Type**.

---

##### 🔧 What Do We Need to Create These Molds?

When we think of a **mold**, the first thing that comes to mind is usually its **shape** — the geometry 🧱✏️  
But in Semio, that shape isn’t just visual — it carries **meaning** 💡

In traditional Grasshopper workflows, geometry is raw: a set of points, edges, and surfaces 🧬  
But in Semio, every shape becomes part of your **design language** 🗣️🎨  
You're not just modeling forms — you're modeling **intent** 🎯

Instead of saying:  
👉 “connect point (x, y, z) to Brep edge 23”  
you say:  
👉 “connect the **door** to the **living room**”  
or in LEGO terms:  
👉 “**snap the window brick onto the top of the wall**” 🪟🧱🏠

🔗 The geometry is still there — but now it's **semantic**.

---

### 🧰 The Essentials of a Type

 Let's go over the essential ingredients for creating a Type:

- **🏷️ Name** → A unique name to identify your Type and reuse it in different designs.  
- **🧱 Geometry (Representation)** → The 3D shape attached to the Type. It gives the piece its visual form.  
- **🧲 Connection Points (Ports)** → The snap points where the piece connects to others in the system.

---

In the next steps, we'll walk through how to set up each of these elements —  
to build a complete, reusable mold, just like designing your own custom LEGO brick.

<Steps>
<ol>
<li>
### 🏷️ Name Your Mold


Giving clear and consistent names to elements in Semio **really pays off later** — especially when designing and making connections.  
As your project grows and you’re working with many Types, Variants, and Pieces, meaningful names make everything easier to navigate and understand.

📝 Try to name things the way you would in a real project — clear, specific, and with purpose.



##
</li>
<li>
### 🧊 Attach Geometry (Model Representation)



In Semio, when you give a Type its shape, you're adding a **Representation** 🧱

It’s like snapping a plastic shell onto a LEGO mold — now your brick has a visible form 👀  
This shape is the geometry, but it’s not fixed. A Representation is more like a **costume** — you can swap it anytime, as long as it fits.

Just like architects use a simple block for city models 🏙️ and a detailed one for close-ups 🪟,  
Semio lets you change the **look** without changing the **logic** 🔄

Same brick, different shell — that’s a Representation 💡

---


To model a Representation, you first need to create the **geometry** — the body of your building block.

semio lets you attach geometry to a Type in **two main ways**, each with its own strengths 🚀


---



We will now discover a hands on of doing both on our example :

Lets try to model our shapes as you see is a rectangle, cut at an angle

As you can see the different design Parameters in the sketch :

- `W` = a single Unit Dimensions  
  `n` = Number of segments (length of each element

<Tabs>
<TabItem label="Direct Reference">
For now we will develop This Shape a logic has been created to generate it based on how many Units it has in its length.

We have created a Grashopper logic that first generate this Rectangular shape cut and then Create a wood profile out of this curve
</TabItem>
<TabItem label="File-Based Reference (🔁 Recommended)">
We could model the Geometry we want to attach at the end we reference a layer
</TabItem>
</Tabs>

💡 **Tip:** Choose the method that fits your workflow best.  
 Want to dive deeper into the pros and cons? Learn more here 🔍


#### 🧪 Representation as a Placeholder

Use different Representations for the same design — depending on the level of detail needed.

<Tabs>

<TabItem label="🔍 Detailed Version">
Display a high-detail Representation of the model —  
includes elements like profiles, joints, or textures.
</TabItem>

<TabItem label="⚡ Simplified Version">
Display a simplified Representation of the same model —  
basic geometry used for fast modeling or large-scale views.
</TabItem>

</Tabs>




---
</li>
<li>
### ⚓ Add Connection Points (Model Ports)

Once you've modeled the visual look of your brick mold (Representation), it's time to decide **where** these bricks connect to each other.  
 That's where **Ports** come in — the snap points that define where a Brick can attach 🧲

##### 🧩 What Do You Need to Define a Port?

In the semio Grasshopper plugin, each Port is defined with 3 main inputs:

- **A Point** 📍  
   This is the location where the connection happens.  
   Think of it as the exact stud or socket on your Lego brick. You choose this point carefully on the surface of your geometry.

- **A Vector** ➡️  
   This defines the direction the Port faces.  
   It's like saying: "This side is meant to connect outward."  
   The vector is especially important later when aligning pieces — because semio uses this direction to orient other parts when snapping.

- **A Port ID** 🏷️  
   This is the name of the Port — a label you'll use when connecting components.  
   For example: `"n"` (north), `"bottom"`, or `"hingePoint"`.

##### 🏷️ About Port IDs

A **Port ID** is the label you give to each Port.  
 This naming is important — because later, when you make connections, you'll say things like:

"Connect Piece A's `top` Port to Piece B's `bottom` Port."

You can choose any naming system — as long as it makes sense in your design logic.  
 In this example, we use:

- `n`, `s`, `e`, `w` — standing for **north, south, east, and west** 🧭

But in your own projects, you might use:

- `top`, `bottom`, `hinge`, `plug`, `outlet`, `windowDock` — or anything else 🔧

💡 **Tip**: Choose a consistent and meaningful naming system. It will make connecting components easier — and later on, it helps when working with AI or team members.

##### 💡 Tip: Where Should You Place Ports?

Don't just place Ports where pieces touch — place them where they make sense **logically and consistently** across all Variants.

🔧 Here's how to decide:

- 📍 **Place Ports in central or stable locations**  
  (e.g. the center of a face or edge, not the outermost corner)

- ♻️ **Use the same Port positions for all Variants of a Type**  
  This keeps your snapping logic reusable, even if the shapes vary

- 🎯 **Don’t worry about perfect alignment**  
  Semio lets you adjust a Piece’s position and rotation *after* it snaps

---

##### 💡 Tip: How Many Ports Should You Add?

There’s no fixed number — it depends on how much flexibility you want in your design system.

🧱 Think of it like LEGO:

- 🔒 **Use fewer Ports** for simple, strict snapping  
  (e.g. one Port per face or side)

- 🔓 **Add more Ports** if you want options for different layouts or orientations

- 🧠 **Plan ahead**: Add the Ports you might need later, even if you don’t use them right away

Here more Grasshopper
</li>
<li>
### 🧱 Assemble the Mold (Model Type)

After modeling all the parts of your brick mold —  
 **Name**, **Variant**, **Ports**, and **Representation** —  
 you plug them into the `Typ` component.

- 🏷️ **Name** → e.g. "Profile"

- 🔢 **Variant** → e.g. 2

- 🧲 **Ports** → e.g. n, s, e, w

- 🧊 **Representation** → the linked geometry

🎯 The result is a complete **Type** —  
 a smart, reusable building block ready to be placed and connected in your Design.

 

Think of it as snapping all the mold info together — now you have your custom LEGO brick 🔧🧱



---
</li>
</ol>
</Steps>


## 🧬 Mold Versions (Variants of Type)
→ Use the same mold to make bricks of different sizes

Now that you've created your base **Type**, it's time to generate **Variants** — based on the **unit count `n`** shown in the sketch.

Each Variant uses the **same mold**, just stretched or scaled.  
 Think of it like longer or shorter Lego bricks of the same kind 🧱🧱🧱  
 Since they follow the same design logic, we treat them as **Variants** of one **Type**, not separate Types.

#### 🔢 From the Sketch:

- **Variant 2** → 2 units long

- **Variant 4** → 4 units long

- **Variant 5** → 5 units long

---

#### 🔁 How to Model a Variant in semio

To model a Variant, you follow **the same steps** as creating a Type —  
 but with **two key differences**:

1. **Reuse** the original **Type name**

2. **Assign** a **unique Variant name** (e.g. the unit count `n`)

This tells semio:  
 ➡️ "Same mold, different size."

✅ Just like with Types, you have **three ways** to reference geometry:

- Direct from Grasshopper or Rhino Layer

- External file (recommended)

---

#### 💡 Advanced Tip: Use Clusters to Generate Variants

In Grasshopper, a smart way to manage **Variants** is by using a **Cluster** —  
 essentially a reusable mold-maker that builds each version of your LEGO brick 🧱

Since Variants are mostly identical and only differ by one or two inputs,  
 the Cluster helps you model everything once and repeat only what's necessary.

**Inside the Cluster:**  
 You define the full Type logic —

- Geometry generation
- Representation attachment (Model Representation)
- Port placement (Model Port)
- Type creation (Model Type)

**Outside the Cluster:**  
 You feed in only what changes:

- `n` → the unit count (e.g. 2, 4, 5), which controls the shape size 📏

- Variant name → In this Case it is also `n` 🏷️

This way, you can generate multiple Variants from the same Type mold —  
 without duplicating anything or cluttering your canvas.

✅ **Bonus:** Keeps your file organized and scalable — perfect for growing your Kit later on.

Showcase the three different methods :

Cluster without referencing

Cluster with referencing Files

Note > If the Shape would be different you would create a new type instead of Variants of the same type


---

