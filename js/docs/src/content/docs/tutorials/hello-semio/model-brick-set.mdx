---
title: 🧱 Create Brick Set
description: All steps to break down, mold, and make variants of your model bricks.
sidebar:
  order: 2
---

import { Steps, Tabs, TabItem } from "@astrojs/starlight/components";



As mentioned earlier in **[Thinking in Semio](/think-in-semio/)**, a **Type** is like a **brick mold**.  

You're not just drawing geometry — you're designing a **template** that combines shape with meaningful design information.

---

#### 🧩 What Are the "Molds" in This Example?

Take a look at your sketch — you'll see five elements that follow the **same basic shape**, just stretched to different lengths.

Even though the final Design includes five Pieces, they're made from only **three distinct shapes**,  
with two of them used twice — giving us **three Variants of one Type**.

🧱 Think of it like a LEGO brick that comes in 2-stud, 4-stud, and 5-stud versions — same shape logic, just scaled.

If the shape were completely different — like a triangle, window, or roof — that would count as a **new Type** altogether.


---

#### 🔧 What Do We Need to Create These Molds?

When you think of a mold, the first thing that comes to mind is usually its **shape** — the geometry 🧱✏️  
But in Semio, geometry is more than form — it serves as a **placeholder for meaning** 💡

In traditional Grasshopper workflows, geometry is just raw data 🧬  
But in Semio, it becomes part of your **design language** 🗣️🎨 — a way to represent **intent**, not just surfaces 🎯

For example:  
👉 Instead of saying "connect point (x, y, z) to Brep edge 23"  
👉 You say "connect the **door** to the **living room**"  
👉 Or in LEGO terms: "**snap the window brick onto the top of the wall**" 🪟🧱

🔗 The geometry still exists — but now it stands in for something more: **a role, a relationship, a meaning**.


---

## 🧰 What makes a Brick Mold (Type)?

Let's go over the essential ingredients for creating a Type:

- **🏷️ Name** → A unique name to identify your Type and reuse it in different designs.  
- **🧱 Geometry (Representation)** → The 3D shape attached to the Type. It gives the piece its visual form.  
- **🧲 Connection Points (Ports)** → The snap points where the piece connects to others in the system.

Let’s take a look at the elements that make up a Type, and dive into modeling our first brick mold.

<Steps>
<ol>

<li>

### 🏷️ Name Your Mold (Type Name)

Giving clear and consistent names to elements in Semio **really pays off later** — especially when designing and making connections.  
As your project grows and you're working with many Types, Variants, and Pieces, meaningful names make everything easier to navigate and understand.

📝 Try to name things the way you would in a real project — clear, specific, and with purpose.

---

</li>

<li>

### 🧊 Attach Geometry (Model Representation)

In Semio, when you give a Type its shape, you're adding a **Representation** 🧱  
This isn’t just visual geometry — it’s a **layer of meaning** that stands in for a design element.

Think of it like snapping a shell onto a LEGO mold — now your brick has a visible form 👀  
But that form isn’t fixed. A Representation is more like a **costume** — it can be swapped at any time, as long as it fits the logic.

Just like architects might use a blocky mass for urban models 🏙️ or detailed profiles for close-ups 🪟,  
Semio lets you change the **look** without changing the **design logic** 🔄  
Same brick, different shell — that’s the idea 💡

---

#### 🔧 How to Model a Representation

To add a Representation, you first need to create the actual **geometry** — the body of your building block.  
In Semio, you can attach this geometry to a Type in **two main ways**, depending on your workflow:

<Tabs>

<TabItem label="Direct Reference">

Use a parametric definition in Grasshopper to generate the shape.  
In our example, the geometry is a rectangle, cut at an angle and extruded into a wooden profile.  
The length is defined by two parameters:

- `W` = unit width  
- `n` = number of segments

</TabItem>

<TabItem label="File-Based Reference (🔁 Recommended)">

Model the shape externally (e.g. in Rhino), then attach it to your Type by referencing a named layer.

</TabItem>

</Tabs>

##### 💡 Tip: Choose the method that best fits your workflow.  
Want to go deeper into the pros and cons? Learn more here 🔍

---

#### 🧪 Representation as a Placeholder

Representations can be swapped — they’re just one way to **visualize** a design, not define it.  
That means you can use **different versions** of the same Type depending on your needs:

<Tabs>

<TabItem label="🔍 Detailed Version">

Use a high-detail Representation with features like joints, profiles, or textures — ideal for fabrication or close-up studies.

</TabItem>

<TabItem label="⚡ Simplified Version">

Use a simplified shape — fast to render and easier to work with at larger scales.

</TabItem>

</Tabs>

This flexibility helps keep your model lightweight while preserving the underlying logic.


### ⚓ Add Snapping Points (Model Ports)

Once you've modeled the visual look of your brick mold (Representation), it's time to decide **where** these bricks connect to each other.  
That's where **Ports** come in — the snap points that define where a Brick can attach 🧲

---

#### 🧩 What Do You Need to Define a Port?

In the Semio Grasshopper plugin, each Port is defined with three main inputs:

- **A Port ID** 🏷️  
  The name of the Port — a label used to define connections, such as `"n"`, `"bottom"`, or `"hingePoint"`.

- **A Point** 📍  
  The exact location where the connection happens — like the stud or socket on a LEGO brick.  
  You place it carefully on the surface of your geometry.

- **A Vector** ➡️  
  The direction the Port faces — like saying “this side connects outward.”  
  It’s important for aligning pieces when snapping.

---

#### 🏷️ Port ID

A **Port ID** is the label you give to each Port.  
This naming is important — because later, when you make connections, you'll say things like:

> "Connect Piece A's `top` Port to Piece B's `bottom` Port."

You can choose any naming system — as long as it makes sense in your design logic.  
In this example, we use:

- `n`, `s`, `e`, `w` — standing for **north, south, east, and west** 🧭

In your own project, you might use:

- `top`, `bottom`, `hinge`, `plug`, `outlet`, `windowDock` — or anything else 🔧

💡 **Tip:** Choose a consistent and meaningful naming system.  
It will make connecting components easier — and helps when working with AI or teammates.

---

#### 💡 Port Location

Don't just place Ports where pieces touch — place them where they make sense **logically and consistently** across all Variants.

Here’s how to decide:

- 📍 **Place Ports in central or stable locations**  
  (e.g. the center of a face, edge, corner, or endpoint — not just randomly on a surface.
Symmetry is often helpful for keeping your logic clean and reusable.)

- ♻️ **Use the same Port positions for all Variants of a Type**  
  This keeps your snapping logic reusable, even if the shapes vary

- 🎯 **Don't worry about perfect alignment**  
  Semio lets you adjust a Piece's position and rotation *after* it snaps

---

#### 💡 Port Count

There’s no fixed number — it depends on how much flexibility you want in your design system.

- 🔒 **Use fewer Ports** for simple, strict snapping  
- 🔓 **Add more Ports** if you want layout or orientation flexibility  
- 🧠 **Plan ahead:** Add Ports you might need later, even if you don't use them right away

---

</li>

<li>

### 🧱 Assemble the Mold (Model Type)

After modeling all the parts of your brick mold —  
**Name**, **Variant**, **Ports**, and **Representation** —  
you plug them into the `Typ` component.

- 🏷️ **Name** → e.g. `"Profile"`  
- 🔢 **Variant** → e.g. `2`  
- 🧲 **Ports** → e.g. `n`, `s`, `e`, `w`  
- 🧊 **Representation** → the linked geometry

🎯 The result is a complete **Type** —  
a smart, reusable building block ready to be placed and connected in your Design.

Think of it as snapping all the mold info together — and voilà, you've made your custom LEGO brick 🔧🧱

---

</li>

</ol>
</Steps>



## 🧬 Mold Versions (Variants of Type)
→ Use the same mold to make bricks of different sizes

Now that you've created your base **Type**, it's time to generate **Variants** — based on the **unit count `n`** shown in the sketch.

Each Variant uses the **same mold**, just stretched or scaled.  
 Think of it like longer or shorter Lego bricks of the same kind 🧱🧱🧱  
 Since they follow the same design logic, we treat them as **Variants** of one **Type**, not separate Types.

#### 🔢 From the Sketch:

- **Variant 2** → 2 units long

- **Variant 4** → 4 units long

- **Variant 5** → 5 units long

---

#### 🔁 How to Model a Variant in semio

To model a Variant, you follow **the same steps** as creating a Type —  
 but with **two key differences**:

1. **Reuse** the original **Type name**

2. **Assign** a **unique Variant name** (e.g. the unit count `n`)

This tells semio:  
 ➡️ "Same mold, different size."

✅ Just like with Types, you have **three ways** to reference geometry:

- Direct from Grasshopper or Rhino Layer

- External file (recommended)

---

#### 💡 Advanced Tip: Use Clusters to Generate Variants

In Grasshopper, a smart way to manage **Variants** is by using a **Cluster** —  
 essentially a reusable mold-maker that builds each version of your LEGO brick 🧱

Since Variants are mostly identical and only differ by one or two inputs,  
 the Cluster helps you model everything once and repeat only what's necessary.

**Inside the Cluster:**  
 You define the full Type logic —

- Geometry generation
- Representation attachment (Model Representation)
- Port placement (Model Port)
- Type creation (Model Type)

**Outside the Cluster:**  
 You feed in only what changes:

- `n` → the unit count (e.g. 2, 4, 5), which controls the shape size 📏

- Variant name → In this Case it is also `n` 🏷️

This way, you can generate multiple Variants from the same Type mold —  
 without duplicating anything or cluttering your canvas.

✅ **Bonus:** Keeps your file organized and scalable — perfect for growing your Kit later on.

Showcase the three different methods :

Cluster without referencing

Cluster with referencing Files

Note > If the Shape would be different you would create a new type instead of Variants of the same type


---

