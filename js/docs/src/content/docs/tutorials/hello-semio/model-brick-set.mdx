---
title: ğŸ§± Create Brick Molds
description: All steps to break down, mold, and make variants of your model bricks.
sidebar:
  order: 2
---

import { Steps, Tabs, TabItem } from "@astrojs/starlight/components";



As mentioned earlier in **[Thinking in Semio](/think-in-semio/)**,  
A **Type** is your brick mold ğŸ§± The Blueprint behind each Brick  
It defines not just the shape, but also the design meaning and connection logic ğŸ”§


---

##### ğŸ§© What Are the "Molds" in This Example?

Take a look at your sketch ğŸ‘€  
You'll see five elements that follow the **same basic shape**, just stretched to different lengths ğŸ“

Even though the final Design includes five Pieces, they're made from only **three distinct shapes**  
with two of them used twice â€” giving us **three Variants of one Type** ğŸ”¢

ğŸ§± Think of it like a LEGO brick that comes in 2-stud, 4-stud, and 5-stud versions â€”  
same shape logic, just scaled ğŸ“

If the shape were completely different â€” like a triangle, window, or roof â›°ï¸ğŸªŸğŸ   
That would count as a **new Type** altogether

---

##### ğŸ§  Modeling with Meaning


When you think of a mold, the first thing that comes to mind is usually its **shape** â€” the geometry ğŸ§±âœï¸  
But in Semio, the **mold** is what combines **shape** with **meaningful design information** ğŸ’¡

In traditional Grasshopper workflows, youâ€™re modeling with **raw data** â€” points, curves, and surfaces without embedding **design intent** ğŸ§¬  
You build logic around it, but that logic stays detached â€” abstract, custom, and often fragile.

> In **Semio**, the mold connects geometry with design intent directly ğŸ§   
> You're not referencing arbitrary geometry â€” you're referencing **relationships**, **roles**, and **rules** ğŸ§©

For example:  
ğŸ‘‰ Instead of saying "connect point (x, y, z) to Brep edge 23"  
ğŸ‘‰ You say "connect the **door** to the **living room**" ğŸ›‹ï¸ğŸšª  
ğŸ‘‰ Or in LEGO terms: "ğŸªŸ **snap the window brick onto the top of the wall**" ğŸ§±

This is what gives Semio its strength â€” youâ€™re not just building shapes,  
youâ€™re building a **semantic system** that adapts, scales, and speaks your design language ğŸ¯ğŸ—£ï¸

---

## ğŸ§° Create a Brick Mold ([Type](/think-in-semio/#type) â€“ Ty)

Letâ€™s begin by modeling the mold shown in the sketch  
This will serve as the base for generating its **Variants** ğŸ§©

![ğŸ“¤ sketch drawing](/sketch-drawing-mold.png)

Before we start building, letâ€™s go over the essential elements that define a **Type** ğŸ§±:

- ğŸ·ï¸ **Name** â†’ A unique name to identify your Type and reuse it in different designs  
- ğŸ§± **Geometry (Representation)** â†’ The 3D shape attached to the Type â€” it gives the piece its visual form âœ¨  
- ğŸ§² **Connection Points (Ports)** â†’ The snap points where the piece connects to others in the system ğŸ”—

Now letâ€™s take a closer look at how these elements come together â€” and start modeling our first **brick mold** ğŸ› ï¸



<Steps>
<ol>

<li>

### ğŸ·ï¸ Name Your Mold ([Type](/think-in-semio/#type) Name - Na)

Clear, consistent names in Semio make everything easier down the line âœ…  
Especially when your project grows and you're working with many **Types**, **Variants**, and **Pieces** ğŸ”„

Good names help you:

- ğŸ§­ **Navigate** your system  
- ğŸ” **Understand** relationships  
- ğŸ”— **Make connections** that are easy to track

:::note
Use names you'd use in a real project â€” specific, descriptive, and purposeful ğŸ“ 
:::

ğŸ‘‰ In our example, weâ€™ll name our Type **"Profile"**  
because the shape we're modeling is based on a **standard manufactured wood profile** ğŸªµ


---

</li>

<li>

### ğŸ§Š Attach Geometry (Representation â€“ Rp)

In Semio, the process of adding geometry to a Type is called **modeling its Representation** ğŸ› ï¸
A **Representation** is anything that visually or symbolically **represents a Type** ğŸ§±
It helps you **see or recognize** the Type â€” without defining its logic or behavior ğŸ§ 

In most cases, this will be a **3D geometry**, like in our example
But it can also be:

- A 2D drawing or diagram âœï¸  
- A symbolic icon or block ğŸ”³  
- A label, file, or reference ğŸ”–

ğŸ’¡ Because Representations are separate from the logic of the system, theyâ€™re fully flexible:

- You can start modeling your system without one ğŸš§  
- You can add or update it later ğŸ› ï¸  
- You can switch between levels of detail depending on the design phase ğŸ”

In this example, weâ€™ll use a **simple 3D shape** to represent our brick molds we need to create ğŸ§©


---

##### ğŸ”§ Modeling Representation

There are two simple steps to create a **Representation**:

- ğŸ› ï¸ **Build the Geometry**  
  Model the physical form of your brick â€” the shape that will appear in your design

- ğŸ“ **Link it to the Type**  
  Connect the geometry to a specific Type, so Semio knows how to display and use it in your design space


Letâ€™s take a closer look at the **brick mold** in our example ğŸ‘€  
It always follows the **same basic shape** ğŸ§±  
A **rectangle thatâ€™s cut at an angle** âœ‚ï¸ â€” just repeated in different lengths ğŸ“  

As we saw in the sketch, its size is described using **two parameters**:

- `W` â†’ the width of one brick unit  
- `n` â†’ the number of units in length

---

In **Semio**, you can attach geometry to a Type in different ways ğŸ”„  
You can pick the method that best fits your **workflow or tool**.  

Letâ€™s take a look at how that works in practice ğŸ‘‡ 



<Tabs>

<TabItem label="File-Based Reference (ğŸ” Recommended)">



In **Semio**, Representations are typically referenced through **external geometry files** ğŸ—‚ï¸  
â€” even when those files are generated inside **Grasshopper**

This approach keeps your workflow **clean**, **modular**, and **easy to update** ğŸ§¼  
It also makes your design system more **reusable** and **scalable** ğŸ”

While the modeling process itself isnâ€™t the focus of this tutorial,  
hereâ€™s the key takeaway:  
Youâ€™ll need to follow **three simple steps** to attach your geometry as a **Representation** ğŸ§±

---

#### ğŸ› ï¸ Geometry Modeling

Since our shape follows a clear logic ğŸ§   
we use a **parametric Grasshopper definition** to generate the geometry of the brick mold ğŸ§±  

This is useful because it lets us generate **all the different Variants** of this brick seen in the sketch  
using a single logic controlled by the parameters `n` and `W`  
which define the brickâ€™s length and width ğŸ“

![ğŸ“ Geometry Generation](/attach-geometry-crop.gif)

---

#### ğŸ’¾ Geometry Export

After generating the geometry,  
we need to **export it as a `.glb` file** so it can be attached as a **Representation** ğŸ’¾

Weâ€™ll use a **simple workflow** that automates this export ğŸ¦¾  
You can place it **directly after** your geometry generation step in Grasshopper ğŸ¦—

---

ğŸ” The Export Workflow Looks Like This:

![ğŸ“¤ Export Geometry](/export-geometry.png)

---

##### ğŸ—‚ï¸ Set the Export Location  
Use the `Dir` and `Path` components to define the directory path  
This determines where the exported file will be saved

##### ğŸ“ Build the File Name  
Use `Concat` to generate the file name dynamically  
Combine the Type name and Variant (e.g. `profile` + `2`) â†’ `profile_2.glb`

##### ğŸ§© Assemble the Full File Path  
Another `Concat` merges directory + file name:  
`C:\Users\Users\Downloads\profile_2.glb`

##### ğŸ“ Prepare the Geometry

> ğŸ› ï¸ You've already modeled the geometry earlier in your Grasshopper definition.  
> Now it's time to **export** it â€” so Semio can use it as a **referenced Representation** ğŸ’¾

- âœ… Convert the geometry into the required format (e.g. **Mesh** for `.glb`)
- ğŸ“¤ Pass it into the `iGeo` component to export it as a `.glb` file  


Your file directory should now look like this:

![ğŸ“¤ Exported file](/file-export-Profile-2-.png)

---

:::note
âš™ï¸ This method combines the **parametric power of Grasshopper** with the **modular logic of Semio**  
ğŸ“¤ Every time a parameter changes, the file can be **re-exported automatically** â€”  
ready to be referenced in the next step  
:::


---

#### ğŸ”— Referencing the Exported File

The exported file (e.g. `profile_2.glb`) is linked to the **`Ur` input** of the **Model Representation** component (`~Rep`)  
This tells Semio **where to find the geometry** that represents your Type.

- ğŸ§© The **`~Rep` (Model Representation)** component takes the `Ur` file path and creates a Representation:  
  â†’ `Rep(model/gltf-binary)`

- ğŸ”— This Representation is later connected to the **`Typ` (Model Type)** component â€”  
  so that your Type is linked to its visual form

![ğŸ“ Reference Geometry](/reference-geometry.png)

---

### ğŸ” Why Use File-Based Referencing?

Even inside Grasshopper, Semio requires a **file-based snapshot** of your geometry â€”  
a static file that captures what your brick mold looks like at a specific moment.

Hereâ€™s why that matters:

- âš™ï¸ If your geometry is dynamic or parametric, it still needs to be **exported to a file**  
- ğŸ”— Semio connects to that file â€” not the live Grasshopper preview

> ğŸ’¡ This keeps geometry **modular**, **portable**, and easy to reuse  
> ğŸ§± It also supports **chunking** â€” breaking down large designs into smaller, manageable parts  
> ğŸŒ And it allows smooth transition between **Grasshopper** and **Semio Sketchpad**





</TabItem>

<TabItem label="Direct Reference">



You donâ€™t always need to embed geometry directly into a Type ğŸ§±
In some cases, you can skip integration and reference the geometry directly in Grasshopper instead ğŸ›ï¸

Just pass the geometry â€” either as a Geometry ğŸ§Š or Object ğŸ§© â€” straight into the Preview Design component ğŸ‘€
This lets you visualize your Design using custom shapes without embedding them into the Typeâ€™s definition ğŸ”

ğŸ‘‰ Weâ€™ll explore this option in a later step.
âš ï¸ Just note: this method is for visualization only â€” the geometry wonâ€™t be part of the mold itself

</TabItem>

</Tabs>


---

#### ğŸ§ª Switching the Representation 

As introduced earlier, when you give a **Type** its shape in Semio, you're attaching a **Representation** â€”  
a piece of geometry that shows what the brick looks like visually ğŸ‘ï¸

But this geometry isnâ€™t fixed â€” it acts more like a **placeholder** ğŸ§   
That means you can **change or swap** the Representation at any time **without breaking your design logic** ğŸ”

You can think of it like a **costume** for your Type ğŸ­  
The name, role, and connections stay the same â€” you're just changing how it looks on stage ğŸ¬

This flexibility is especially useful when working across **different levels of detail** in a project ğŸ§©

Just like architects might use **blocky volumes** for urban massing ğŸ™ï¸  
and **detailed profiles** for close-ups or fabrication ğŸªŸ  
Semio lets you swap the **look** without changing the **logic** ğŸ”„  
Same brick â€” different shell ğŸ’¡

##### ğŸ¬ One Brick, various Representations

To illustrate this concept, we created **two geometry files** for the **same brick mold Type**:

---

<Tabs>

<TabItem label="ğŸ” Detailed Version">

This version uses the **fully detailed geometry** of the piece ğŸªµ  
A rectangle cut at an angle and extruded into a realistic wooden profile âœï¸  
It includes every visible detail in 3D: full depth, edges, and joinery-ready shapes ğŸ”  

![ğŸ“ Switch Representation](/Switch-Representation.png)  
![ğŸ“ Filename](/Profile-2-detailed.png)

Best for:
- ğŸªš Joinery and production planning  
- ğŸ“ Material-specific outputs  
- ğŸ–¼ï¸ Detailed documentation and renders  

</TabItem>

<TabItem label="ğŸ“„ Sheet Version">

This version is a **flat sheet simplification** ğŸ“„  
A single-surface geometry that represents the general size of the piece ğŸ“  
It captures only **one dimension** and skips all 3D detail ğŸš«

![ğŸ“ Switch Representation](/switch-representation-sheet.png)  
![ğŸ“ Filename](/Profile-2-simplified.png)

Use this when:
- ğŸ“ Only the 2D footprint is known  
- âœï¸ The full shape is not finalized yet  
- âš¡ You need fast previews or early-stage coordination  

</TabItem>

<TabItem label="ğŸ“¦ Block Version">

This version is a **bounding box simplification** ğŸ“¦  
A simple block that approximates the pieceâ€™s volume â•  
It includes **two dimensions** but omits exact geometry ğŸ§Š 

![ğŸ“ Switch Representation](/switch-representation-Block.png)  
![ğŸ“ Filename](/Profile-2-simplified.png)

Best for:
- ğŸ§ª Early-stage layouts and feasibility checks  
- âš™ï¸ Quick iterations and high-speed previews  
- ğŸ§Š Placeholder geometry before final detailing  

</TabItem>

</Tabs>




---

Even though these two Representations **look very different**  
They both belong to the **same Type** âœ…  

The **Name**, **Variant**, **Ports**, and **logic** stay exactly the same  
Only the appearance changes ğŸ­  

This means you can **design and assemble** everything using lightweight placeholders ğŸ§©  
Then **swap in the detailed version** when you're ready for presentation, communication, or fabrication ğŸ§°  

This separation of **logic and form** is what makes Semio workflows flexible, scalable, and robust ğŸ”„  
From early concept to detailed design to collaborative development ğŸ¤
 


</li>

<li>

### âš“ Add Snapping Points ([Ports](/think-in-semio/#port) - Po)

Once your brick mold has a visual shape â€” its **Representation** â€”  
the next step is to define **how it connects to other bricks**  

Thatâ€™s what **Ports** are for ğŸ§²  
They act as snap points that tell Semio where and how a brick can attach to others  


---

##### ğŸ§© What Do You Need to Define a Port?

In the Semio Grasshopper plugin, each Port is defined with three main inputs:

- ğŸ·ï¸ **Port ID** ( `Id` )  
  A unique name for the Port â€” like a tag or label used to connect it later  
  Examples: `"n"`, `"bottom"`, `"hingePoint"`  

- ğŸ“ **Point** ( `Pt` )  
  The exact spot where the connection happens â€” like placing a stud on a LEGO brick ğŸ§±  
  You place this carefully on your geometry, right where the snapping should occur  

- â¡ï¸ **Vector** ( `Dr` )  
  The direction the Port faces â€” telling Semio which way the brick will connect ğŸ”  
  Itâ€™s what lets Semio rotate and align the bricks correctly when snapping them together  


![ğŸ“ Ports](/model-port-alpha.png)

---



#### ğŸ“ Port Location (`Pt`)

When modeling Ports, itâ€™s not just about **where** pieces touch â€”  
itâ€™s about building a **clear and reusable logic** that works across all Variants ğŸ§ ğŸ”

---

Hereâ€™s how to define your Ports effectively:

- ğŸ§± **Choose stable, meaningful locations**  
  Choose positions that are geometrically logical â€” like the **center of a face**, an **edge midpoint**, or a **corner** ğŸ§©  
  Avoid placing them randomly â€” symmetry and regular patterns help your logic stay clean â™»ï¸

- ğŸ“ **Keep positions consistent across Variants**  
  Even if your bricks differ in size or shape, place Ports in the **same relative location** ğŸ”„  
  This way, your connection rules stay valid across all versions of a Type ğŸ§°

- ğŸ¯ **Donâ€™t worry about perfect alignment**  
  Ports donâ€™t need to be *exactly* placed.  
  Semio lets you adjust each Pieceâ€™s **position and rotation** *after* snapping ğŸ› ï¸  
  So prioritize clear logic over micrometer precision ğŸ˜Œ


---

Thereâ€™s no strict rule for how many Ports to add â€” it depends on how much flexibility your system requires:

- ğŸ”’ **Fewer Ports** â†’ simpler, more controlled snapping  
- ğŸ”“ **More Ports** â†’ more layout options and greater orientation flexibility 
- ğŸ§  **Plan ahead** â†’ add Ports you might need later, even if theyâ€™re not used right away


ğŸ‘‰ *In our example, we place four Ports â€” one at the center of each edge of a four-sided profile* ğŸ§±


---

#### ğŸ’¡ Port Direction (Dr)

Every Port needs a **direction** â€” a vector that tells Semio which way the connection should face ğŸ§­  
This is how Semio knows how to align and snap your Pieces together correctly ğŸ§²

Hereâ€™s how to define Port directions clearly:


- ğŸ“ **Use clean, simple vectors**  
  Stick to basic axes like **X, Y, or Z**  relative to the face the Port sits on. It makes snapping easier and logic more readable ğŸ§   
  Avoid random or diagonal directions unless needed

- â™»ï¸ **Be consistent across Variants**  
  Ports donâ€™t need to be perfectly precise â€” but they **must stay consistent**  
  This ensures all your bricks connect correctly no matter the shape or version ğŸ”§

ğŸ‘‰ *In our example, each Port faces straight out â€” perpendicular to the edge itâ€™s placed on* ğŸš€


---
#### ğŸ·ï¸ Port ID (Id)

A **Port ID** is the name you give to each Port ğŸ·ï¸  
This name is how Semio knows **which Port to connect** when snapping Pieces together

For example, you might say:  
> "Connect the `top` Port of Piece A to the `bottom` Port of Piece B"

You can use **any naming system** â€” as long as itâ€™s clear and consistent:

- Common examples: `n`, `s`, `e`, `w` â€” for north, south, east, and west ğŸ§­  
- Custom names: `top`, `bottom`, `hinge`, `plug`, `windowDock`, etc. ğŸ§²

ğŸ’¡ **Tip:** Pick a naming system thatâ€™s easy to understand and stick to it  
It helps you stay organized and makes teamwork or AI assistance much easier ğŸ¤

---

Together with the **Pt** (position) and **Dr** (direction), the **Id** completes each Port definition:  
Each row in the three lists defines one Port â€” so all lists must be the **same length** to stay in sync ğŸ§©



---

Now you can see how the three inputs â€” Id, Pt, and Dr â€” work together to create Ports.
Each Port is defined by one entry from each list, so the lists must be the same length.
This ensures that every snapping point has a matching ID, position, and direction



  


</li>

<li>

### ğŸ§± Assemble the Mold (Model [Type](/think-in-semio/#type))

Once youâ€™ve defined all parts of your brick mold   
the **Name**, **Variant**, **Ports**, and **Representation**   
you can assemble them using the `Model Type` component (`Typ`) ğŸ§°

Here's what you plug in:

- ğŸ·ï¸ **Name** â€” the shared identity of the mold (e.g. `"Profile"`)
- ğŸ”¢ **Variant** â€” the specific version number (e.g. `"2"`)
- ğŸ§² **Ports** â€” the snapping points and directions (e.g. `n`, `s`, `e`, `w`)
- ğŸ§Š **Representation** â€” the geometry that defines the brick's shape

  
![ğŸ“ Model Type](/model-type.png)  
![ğŸ“ Model Type](/model-type-geo.png)

---

ğŸ¯ The result is a complete **Type**   
A reusable brick mold that carries both shape and connection logic

For example, `Typ("Profile", 2)`  
creates Variant `2` of the `"Profile"` mold   
a 2-unit-long brick ready to be placed in your Design ğŸ§±




---

</li>

</ol>
</Steps>


## ğŸ§¬ Create Mold Versions (Variants of [Type](/think-in-semio/#type))

![ğŸ“¤ sketch drawing](/sketch-drawing-variant.png)

Now that you've created your base **Type**, it's time to generate **Variants** â€” based on the **unit count `n`** shown in the sketch ğŸ”¢

Each Variant is built from the **same mold**, just stretched or scaled to a different length ğŸ“  
Think of it like longer or shorter LEGO bricks of the same kind ğŸ§±  
Since they follow the same logic and structure, we treat them as **Variants** of one **Type** â€” not separate Types â™»ï¸

Examples from our sketch:

- `Variant 2` â†’ 2 units long ğŸŸ©ğŸŸ©  
- `Variant 4` â†’ 4 units long ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©  
- `Variant 5` â†’ 5 units long ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©ğŸŸ©  


---

#### ğŸ” Modeling a Variant


---

##### âœ… What Stays the Same

- ğŸ·ï¸ **Type name** â€” youâ€™re still using the same underlying mold

##### ğŸ”„ What Changes?

- ğŸ”¢ **Variant name** â€” a unique label like `2`, `4`, or `5` to distinguish the version  
- ğŸ§Š **Representation** â€” new geometry that reflects the Variantâ€™s shape or size  
- ğŸ§² **Ports** â€” same logic, but positioned relative to the new shape  

---


##### ğŸ› ï¸ Modeling Steps

1. ğŸ·ï¸ Set the **Type name** (same as the original mold)  
2. ğŸ”¢ Assign a new **Variant name**  
3. ğŸ§Š Attach the **Representation** â€” the geometry for this Variant  
4. ğŸ§² Add the **Ports** â€” positioned consistently  
5. ğŸ§± Use the `Model Type` component to combine everything into a complete Variant

---

:::note
Keep Port positions consistent across all Variants â€” it ensures easier snapping and logic reuse
:::

âœ… Thatâ€™s it â€” same mold, new shape, fully ready for modular design

---



##### ğŸ’¡ Advanced Tip: Use Clusters to Generate Variants

In Grasshopper, a great way to handle multiple Variants is with a **Cluster**  

Since most Variants share the same logic and differ by only one or two parameters, a Cluster helps you:

- ğŸ” Model the logic **once**
- âš¡ Generate all Variants **efficiently**
- ğŸ§¼ Keep your script **clean and modular**

![ğŸ“ Variant GIF](/Type-1-to-5-crop.gif)

<Tabs>

<TabItem label="ğŸ“‚ File-Based Geometry Reference">

**Inside the Cluster:**  

You define the full logic:

- ğŸ§Š Generate and export geometry  
- ğŸ“ Link the exported file via `Model Representation`  
- ğŸ§² Place Ports using `Model Port`  
- ğŸ§± Create the Variant using `Model Type`

![ğŸ“ Cluster](/cluster-type-inside-ALpha.png)

**Outside the Cluster:**  

You only feed in the changing inputs:

- ğŸ“ `n` â†’ the unit count (e.g. 2, 4, 5)  
- ğŸ·ï¸ Variant name â†’ often also `n`  
- ğŸ“ Directory of the GH file  
- ğŸ”˜ Export toggle

![ğŸ“ Cluster](/type-cluster-file-reference-Alpha.png)  
![ğŸ“ Cluster](/file-export.png)

</TabItem>

<TabItem label="ğŸ§± Direct Geometry Reference">

**Inside the Cluster:**  

You define the full modeling logic directly, without saving external files:

- ğŸ§Š Generate geometry  
- ğŸ§² Place Ports using `Model Port`  
- ğŸ§± Create the Variant using `Model Type`

![ğŸ“ Cluster](/cluster-type-inside-direct.rfrc.png)

**Outside the Cluster:**  

Only the changing parameters are connected:

- ğŸ“ `n` â†’ the unit count (e.g. 2, 4, 5)  
- ğŸ·ï¸ Variant name â†’ often also `n`

![ğŸ“ Cluster](/type-cluster-direct-reference-Alpha.png)

</TabItem>
</Tabs>

---

âœ… **Bonus:** This workflow keeps your file organized, scalable, and easy to expand â€” perfect for growing your Kit later on ğŸ§©
