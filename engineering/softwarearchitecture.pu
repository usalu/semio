@startuml "software architecture"
skinparam linetype ortho

class Attribute {
  key: str
  value: str
  definition: str
}

class Coord {
  x: float
  y: float
}

class Vec {
  x: float
  y: float
}

class Point {
  x: float
  y: float
  z: float
}

class Vector {
  x: float
  y: float
  z: float
}

class Plane {
  origin: Point
  xAxis: Vector
  yAxis: Vector
}

class Camera {
  position: Point
  forward: Vector
  up: Vector
}

class Location {
  longitude: float
  latitude: float
  altitude: float
  attributes: list[Attribute]
}

class Author {
  name: str
  email: str
  attributes: list[Attribute]
}

class File {
  path: str
  remoteUrl: str
  description: str
  attributes: list[Attribute]
}

interface Model {
  ApplyDiff(Diff diff): Model
  InversedDiff(Diff diff): Diff
}

interface Id {

}

interface Shallow {

}

interface Diff {
  Merge(Diff other): Diff
}

interface Diffs {

}

interface Input {

}

interface Output {

}

interface Context {

}

interface Prediction {

}

' #region Kit

class Kit {
  name: str
  version: str
  types: list[Type]
  designs: list[Design]
  qualities: list[Quality]
  files: list[File]
  authors: list[Author]
  remoteUrl: str
  homepageUrl: str
  license: str
  concepts: list[str]
  icon: str
  image: str
  description: str
  attributes: list[Attribute]
  created: datetime
  updated: datetime
}
Kit -|> Model
Kit *-- "0..*" Design : contains >
Kit *-- "0..*" Type : contains >
Kit *-- "0..*" Quality : defines >
Kit *-- "0..*" Author : has >
Kit *-- "0..*" Attribute : has >
class AttributeId {
  key: str
}
class AuthorId {
  name: str
  email: str
}
class FileId {
  path: str
}
class BenchmarkId {
  name: str
}
class QualityId {
  key: str
}
class PropId {
  key: str
}
class RepresentationId {
  url: str
  tags: list[str]
}
class PortId {
  id: str
}
class TypeId {
  name: str
  variant: str
}
class LayerId {
  name: str
}
class GroupId {
  name: str
}
class PieceId {
  id: str
}
class SideId {
  piece: PieceId
  port: PortId
}
class ConnectionId {
  connecting: SideId
  connected: SideId
}
class StatId {
  key: str
}
class DesignId {
  name: str
  variant: str
  view: str
}
class KitId {
  name: str
  version: str
}
class AttributeDiff {
  key?: str
  value?: str
  definition?: str
}
class LocationDiff {
  longitude?: float
  latitude?: float
  altitude?: float
  attributes?: AttributesDiff
}
class AuthorDiff {
  name?: str
  email?: str
  attributes?: AttributesDiff
}
class FileDiff {
  path?: str
  remoteUrl?: str
  description?: str
  attributes?: AttributesDiff
}
class BenchmarkDiff {
  name?: str
  icon?: str
  min?: float
  minExcluded?: bool
  max?: float
  maxExcluded?: bool
  definition?: str
  attributes?: AttributesDiff
}
class QualityDiff {
  key?: str
  name?: str
  kind?: QualityKind
  default?: float
  formula?: str
  defaultSiUnit?: str
  defaultImperialUnit?: str
  min?: float
  minExcluded?: bool
  max?: float
  maxExcluded?: bool
  canScale?: bool
  benchmarks?: BenchmarksDiff
  definition?: str
  attributes?: AttributesDiff
}
class PropDiff {
  key?: str
  value?: str
  unit?: str
  attributes?: AttributesDiff
}
class RepresentationDiff {
  tags?: list[str]
  url?: str
  description?: str
  attributes?: AttributesDiff
}
class PortDiff {
  id?: str
  point?: Point
  direction?: Vector
  t?: float
  mandatory?: bool
  family?: str
  compatibleFamilies?: list[str]
  description?: str
  attributes?: AttributesDiff
}
class TypeDiff {
  name?: str
  variant?: str
  representations?: RepresentationsDiff
  ports?: PortsDiff
  props?: PropsDiff
  isVirtual?: bool
  canScale?: bool
  canMirror?: bool
  unit?: str
  availableCount?: float
  location?: LocationDiff
  authors?: AuthorsDiff
  concepts?: list[str]
  icon?: str
  image?: str
  description?: str
  attributes?: AttributesDiff
  created?: datetime
  updated?: datetime
}
class LayerDiff {
  path?: str
  isHidden?: bool
  isLocked?: bool
  color?: str
  description?: str
  attributes?: AttributesDiff
}
class GroupDiff {
  pieces?: PiecesDiff
  color?: str
  name?: str
  description?: str
  attributes?: AttributesDiff
}
class PieceDiff {
  id?: str
  type?: TypeId
  design?: DesignId
  plane?: Plane
  center?: Coord
  scale?: float
  mirrorPlane?: Plane
  props?: PropsDiff
  isHidden?: bool
  isLocked?: bool
  color?: str
  description?: str
  attributes?: AttributesDiff
}
class SideDiff {
  piece?: PieceId
  port?: PortId
}
class ConnectionDiff {
  connected?: SideId
  connecting?: SideId
  gap?: float
  shift?: float
  rise?: float
  rotation?: float
  turn?: float
  tilt?: float
  x?: float
  y?: float
  description?: str
  attributes?: AttributesDiff
}
class StatDiff {
  key?: str
  unit?: str
  min?: float
  minExcluded?: bool
  max?: float
  maxExcluded?: bool
}
class DesignDiff {
  name?: str
  variant?: str
  view?: str
  pieces?: PiecesDiff
  connections?: ConnectionsDiff
  stats?: StatsDiff
  props?: PropsDiff
  layers?: LayersDiff
  activeLayer?: LayerId
  groups?: GroupsDiff
  canScale?: bool
  canMirror?: bool
  unit?: str
  location?: LocationDiff
  authors?: AuthorsDiff
  concepts?: list[str]
  icon?: str
  image?: str
  description?: str
  attributes?: AttributesDiff
  created?: datetime
  updated?: datetime
}
class KitDiff {
  name?: str
  description?: str
  icon?: str
  image?: str
  preview?: str
  version?: str
  remote?: str
  homepage?: str
  license?: str
  concepts?: list[str]
  types?: TypesDiff
  designs?: DesignsDiff
  authors?: AuthorsDiff
  attributes?: AttributesDiff
}
class AttributesDiff {
  removed?: list[AttributeId]
  updated?: list[AttributeDiff]
  added?: list[Attribute]
}
class AuthorsDiff {
  removed?: list[AuthorId]
  updated?: list[AuthorDiff]
  added?: list[Author]
}
class FilesDiff {
  removed?: list[FileId]
  updated?: list[FileDiff]
  added?: list[File]
}
class BenchmarksDiff {
  removed?: list[BenchmarkId]
  updated?: list[BenchmarkDiff]
  added?: list[Benchmark]
}
class PropsDiff {
  removed?: list[PropId]
  updated?: list[PropDiff]
  added?: list[Prop]
}
class RepresentationsDiff {
  removed?: list[RepresentationId]
  updated?: list[RepresentationDiff]
  added?: list[Representation]
}
class PortsDiff {
  removed?: list[PortId]
  updated?: list[PortDiff]
  added?: list[Port]
}
class TypesDiff {
  removed?: list[TypeId]
  updated?: list[TypeDiff]
  added?: list[Type]
}
class LayersDiff {
  removed?: list[LayerId]
  updated?: list[LayerDiff]
  added?: list[Layer]
}
class GroupsDiff {
  removed?: list[GroupId]
  updated?: list[GroupDiff]
  added?: list[Group]
}
class PiecesDiff {
  removed?: list[PieceId]
  updated?: list[PieceDiff]
  added?: list[Piece]
}
class SidesDiff {
  removed?: list[SideId]
  updated?: list[SideDiff]
  added?: list[Side]
}
class ConnectionsDiff {
  removed?: list[ConnectionId]
  updated?: list[ConnectionDiff]
  added?: list[Connection]
}
class StatsDiff {
  removed?: list[StatId]
  updated?: list[StatDiff]
  added?: list[Stat]
}
class DesignsDiff {
  removed?: list[DesignId]
  updated?: list[DesignDiff]
  added?: list[Design]
}
class KitsDiff {
  removed?: list[KitId]
  updated?: list[KitDiff]
  added?: list[Kit]
}

' #endregion Kit

class Benchmark {
  name: str
  icon: str
  min: float
  minExcluded: bool
  max: float
  maxExcluded: bool
  definition: str
  attributes: list[Attribute]
}

class QualityKind {
  <<enumeration>>
  General
  Design
  Type
  Piece
  Connection
  Port
}

class Quality {
  key: str
  name: str
  kind: QualityKind
  default: float
  formula: str
  defaultSiUnit: str
  defaultImperialUnit: str
  min: float
  minExcluded: bool
  max: float
  maxExcluded: bool
  canScale: bool
  benchmarks: list[Benchmark]
  definition: str
  attributes: list[Attribute]
}

class Prop {
  key: str
  value: str
  unit: str
  attributes: list[Attribute]
}

class Representation {
  tags: list[str]
  url: str
  description: str
  attributes: list[Attribute]
}

class Port {
  id: str
  point: Point
  direction: Vector
  t: float
  mandatory: bool
  family: str
  compatibleFamilies: list[str]
  description: str
  attributes: list[Attribute]
}

class Type {
  name: str
  variant: str
  representations: list[Representation]
  ports: list[Port]
  props: list[Prop]
  isVirtual: bool
  canScale: bool
  canMirror: bool
  unit: str
  availableCount: float
  location: Location
  authors: list[Author]
  concepts: list[str]
  icon: str
  image: str
  description: str
  attributes: list[Attribute]
  created: datetime
  updated: datetime
}

class Layer {
  path: str
  isHidden: bool
  isLocked: bool
  color: str
  description: str
  attributes: list[Attribute]
}

class Piece {
  id: str
  type: Type
  design: Design
  plane: Plane
  center: Coord
  scale: float
  mirrorPlane: Plane
  props: list[Prop]
  isHidden: bool
  isLocked: bool
  color: str
  description: str
  attributes: list[Attribute]
}

class Group {
  pieces: list[Piece]
  color: str
  name: str
  description: str
  attributes: list[Attribute]
}

class Side {
  piece: Piece
  designPiece: Piece
  port: Port
}

class Connection {
  connected: Side
  connecting: Side
  gap: float
  shift: float
  rise: float
  rotation: float
  turn: float
  tilt: float
  x: float
  y: float
  description: str
  attributes: list[Attribute]
}

class Stat {
  key: str
  unit: str
  min: float
  minExcluded: bool
  max: float
  maxExcluded: bool
}

class Design {
  name: str
  variant: str
  view: str
  pieces: list[Piece]
  connections: list[Connection]
  stats: list[Stat]
  props: list[Prop]
  layers: list[Layer]
  activeLayer: Layer
  groups: list[Group]
  canScale: bool
  canMirror: bool
  unit: str
  location: Location
  authors: list[Author]
  concepts: list[str]
  icon: str
  image: str
  description: str
  attributes: list[Attribute]
  created: datetime
  updated: datetime
}

class Representation {
  url: str
  description: str
  tags: list[str]
  attributes: list[Attribute]
  --
  context Representation inv descriptionCanBeEmpty:
    description->notEmpty() or description->isEmpty()
}

class Port {
  id: str
  description: str
  mandatory: bool
  family: str
  compatibleFamilies: list[str]
  point: Point
  direction: Vector
  t: float
  attributes: list[Attribute]
  --
  context Port inv optionalFieldsCanBeEmpty:
    description->notEmpty() or description->isEmpty() and
    family->notEmpty() or family->isEmpty()
  context Port inv tInValidRange:
    t >= 0 and t < 1
  context Port inv directionIsUnitVector:
    direction.x * direction.x + direction.y * direction.y + direction.z * direction.z = 1
  context Port inv compatibleFamiliesIncludesOwnFamily:
    family->notEmpty() implies compatibleFamilies->includes(family)
}

class Layer {
  name: str
  description: str
  color: str
}

class Group {
  name: str
  description: str
  color: str
  pieces: list[Piece]
  attributes: list[Attribute]
  --
  context Group inv nameCanBeEmpty:
    name->notEmpty() or name->isEmpty()
  context Group inv descriptionCanBeEmpty:
    description->notEmpty() or description->isEmpty()
}

class Family {
  name: str
}

class Piece {
  id: str
  description: str
  plane: Plane
  center: Coord
  scale: float
  mirrorPlane: Plane
  hidden: bool
  locked: bool
  color: str
  type: Type
  design: Design
  piece: Piece
  attributes: list[Attribute]
  --
  context Piece inv descriptionCanBeEmpty:
    description->notEmpty() or description->isEmpty()
  context Piece inv validPieceReference:
    (type->notEmpty() and design->isEmpty() and piece->isEmpty()) or
    (type->isEmpty() and design->notEmpty() and piece->notEmpty())
  context Piece inv colorValidation:
    color->isEmpty() or color.matches('^#[0-9A-Fa-f]{6}$')
  context Piece inv scalePositive:
    scale > 0
  context Piece inv noSelfReference:
    piece <> self
}

class Plane {
  origin: Point
  xAxis: Vector
  yAxis: Vector
  --
  context Plane inv axesAreOrthogonal:
    xAxis.x * yAxis.x + xAxis.y * yAxis.y + xAxis.z * yAxis.z = 0
  context Plane inv axesAreUnitVectors:
    xAxis.x * xAxis.x + xAxis.y * xAxis.y + xAxis.z * xAxis.z = 1 and
    yAxis.x * yAxis.x + yAxis.y * yAxis.y + yAxis.z * yAxis.z = 1
}

class Connection {
  connecting: Side
  connected: Side
  description: str
  gap: float
  shift: float
  rise: float
  rotation: float
  turn: float
  tilt: float
  x: float
  y: float
  attributes: list[Attribute]
  --
  context Connection inv descriptionCanBeEmpty:
    description->notEmpty() or description->isEmpty()
  context Connection inv portsAreCompatible:
    connecting.port.compatibleFamilies->includes(connected.port.family) or
    connected.port.compatibleFamilies->includes(connecting.port.family)
  context Connection inv noDuplicateConnections:
    connecting <> connected
  context Connection inv rotationInValidRange:
    rotation >= -180 and rotation <= 180
  context Connection inv turnInValidRange:
    turn >= -180 and turn <= 180
  context Connection inv tiltInValidRange:
    tilt >= -180 and tilt <= 180
}

class Side {
  piece: Piece
  port: Port
}

class Attribute {
  name: str
  value: str
  unit: str
  definition: str
  --
  context Attribute inv valueCanBeEmpty:
    value->notEmpty() or value->isEmpty()
  context Attribute inv definitionCanBeEmpty:
    definition->notEmpty() or definition->isEmpty()
  context Attribute inv emptyValueMeansTrue:
    value->isEmpty() implies value = 'true'
  context Attribute inv unitCanBeEmpty:
    unit->notEmpty() or unit->isEmpty()
}

class Author {
  name: str
  email: str
}

class Point {
  x: float
  y: float
  z: float
}

class Vector {
  x: float
  y: float
  z: float
  --
  context Vector inv notZeroVector:
    x <> 0 or y <> 0 or z <> 0
}

class Coord {
  x: float
  y: float
}

class Quality {
  key: str
  name: str
  description: str
  uri: str
  scalable: bool
  kind: QualityKind
  si: str
  imperial: str
  min: float
  minExcluded: bool
  max: float
  maxExcluded: bool
  default: float
  formula: str
  benchmarks: list[Benchmark]
  attributes: list[Attribute]
  --
  context Quality inv optionalFieldsCanBeEmpty:
    description->notEmpty() or description->isEmpty() and
    uri->notEmpty() or uri->isEmpty() and
    si->notEmpty() or si->isEmpty() and
    imperial->notEmpty() or imperial->isEmpty() and
    formula->notEmpty() or formula->isEmpty()
  context Quality inv defaultValueInRange:
    (min->notEmpty() implies default >= min) and
    (max->notEmpty() implies default <= max)
  context Quality inv minLessThanMax:
    min->notEmpty() and max->notEmpty() implies min < max
}

class QualityKind {
  <<enumeration>>
  General
  Design
  Type
  Piece
  Connection
  Port
}

class Benchmark {
  name: str
  icon: str
  min: float
  minExcluded: bool
  max: float
  maxExcluded: bool
  --
  context Benchmark inv iconCanBeEmpty:
    icon->notEmpty() or icon->isEmpty()
  context Benchmark inv minLessThanMax:
    min < max
}

class Prop {
  key: str
  value: str
  unit: str
  attributes: list[Attribute]
  --
  context Prop inv unitCanBeEmpty:
    unit->notEmpty() or unit->isEmpty()
}

class Stat {
  key: str
  unit: str
  min: float
  minExcluded: bool
  max: float
  maxExcluded: bool
  --
  context Stat inv unitCanBeEmpty:
    unit->notEmpty() or unit->isEmpty()
  context Stat inv minLessThanMax:
    min < max
}



Design *-- "0..*" Piece : contains >
Design *-- "0..*" Connection : contains >
Design *-- "0..*" Layer : has >
Design *-- "0..*" Group : has >
Design *-- "0..*" Attribute : has >
Design *-- "0..*" Stat : measures >

Type *-- "0..*" Representation : has >
Type *-- "0..*" Port : has >
Type *-- "0..*" Attribute : has >

Piece *-- "1" Type : instance of >
Piece o-- "0..1" Plane : located by >
Piece o-- "0..1" Plane : mirrored by >
Piece *-- "0..*" Attribute : has >
Piece o-- "0..1" Coord : has center >

Group *-- "0..*" Piece : contains >

Connection *-- "0..*" Attribute : has >
Connection o-- "1" Side : connected >
Connection o-- "1" Side : connecting >

Side o-- "1" Piece : refers to >
Side o-- "1" Port : refers to >

Representation *-- "0..*" Attribute : has >

Port *-- "0..*" Attribute : has >
Port *-- "1" Point : at >
Port *-- "1" Vector : oriented by >
Port *-- "1" Family : has >
Port *-- "0..*" Family : compatible with >
Port *-- "0..*" Prop : has >

Plane *-- "1" Point : origin >
Plane *-- "1" Vector : xAxis >
Plane *-- "1" Vector : yAxis >

Quality *-- "0..*" Benchmark : has >
Quality *-- "0..*" Attribute : has >
Quality *-- "1" QualityKind : classified by >

Prop o-- "1" Quality : references >
Prop *-- "0..*" Attribute : has >

Stat o-- "1" Quality : references >

@enduml