@startuml "software architecture"
skinparam linetype ortho

class Attribute {
  key: str
  value: str
  definition: str
}

class Coord {
  x: float
  y: float
}

class Vec {
  x: float
  y: float
}

class Point {
  x: float
  y: float
  z: float
}

class Vector {
  x: float
  y: float
  z: float
}

class Plane {
  origin: Point
  xAxis: Vector
  yAxis: Vector
}

class Camera {
  position: Point
  forward: Vector
  up: Vector
}

class Location {
  longitude: float
  latitude: float
  altitude: float
  attributes: list[Attribute]
}

class Author {
  name: str
  email: str
  attributes: list[Attribute]
}

class File {
  path: str
  remoteUrl: str
  description: str
  attributes: list[Attribute]
}

interface Model {
  ApplyDiff(Diff diff): Model
  InversedDiff(Diff diff): Diff
}

interface Id {

}

interface Shallow {

}

interface Diff {
  Merge(Diff other): Diff
}

interface Diffs {

}

interface Input {

}

interface Output {

}

interface Context {

}

interface Prediction {

}

' #region Kit

class Kit {
  name: str
  version: str
  types: list[Type]
  designs: list[Design]
  qualities: list[Quality]
  files: list[File]
  authors: list[Author]
  remoteUrl: str
  homepageUrl: str
  license: str
  concepts: list[str]
  icon: str
  image: str
  description: str
  attributes: list[Attribute]
  created: datetime
  updated: datetime
}
Kit -|> Model
Kit *-- "0..*" Design : contains >
Kit *-- "0..*" Type : contains >
Kit *-- "0..*" Quality : defines >
Kit *-- "0..*" Author : has >
Kit *-- "0..*" Attribute : has >
class KitId {
  name: str
  version: str
}
class KitDiff {
  name?: str
  description?: str
  icon?: str
  image?: str
  preview?: str
  version?: str
  remote?: str
  homepage?: str
  license?: str
  concepts?: list[str]
  types?: TypesDiff
  designs?: DesignsDiff
  authors?: AuthorsDiff
  attributes?: AttributesDiff
}
class KitsDiff {
  removed?: list[KitId]
  updated?: list[KitDiff]
  added?: list[Kit]
}

' #endregion Kit

class Benchmark {
  name: str
  icon: str
  min: float
  minExcluded: bool
  max: float
  maxExcluded: bool
  definition: str
  attributes: list[Attribute]
}

class QualityKind {
  <<enumeration>>
  General
  Design
  Type
  Piece
  Connection
  Port
}

class Quality {
  key: str
  name: str
  kind: QualityKind
  default: float
  formula: str
  defaultSiUnit: str
  defaultImperialUnit: str
  min: float
  minExcluded: bool
  max: float
  maxExcluded: bool
  canScale: bool
  benchmarks: list[Benchmark]
  definition: str
  attributes: list[Attribute]
}

class Prop {
  key: str
  value: str
  unit: str
  attributes: list[Attribute]
}

class Representation {
  tags: list[str]
  url: str
  description: str
  attributes: list[Attribute]
}

class Port {
  id: str
  point: Point
  direction: Vector
  t: float
  mandatory: bool
  family: str
  compatibleFamilies: list[str]
  description: str
  attributes: list[Attribute]
}

class Type {
  name: str
  variant: str
  representations: list[Representation]
  ports: list[Port]
  props: list[Prop]
  isVirtual: bool
  canScale: bool
  canMirror: bool
  unit: str
  availableCount: float
  location: Location
  authors: list[Author]
  concepts: list[str]
  icon: str
  image: str
  description: str
  attributes: list[Attribute]
  created: datetime
  updated: datetime
}

class Layer {
  path: str
  isHidden: bool
  isLocked: bool
  color: str
  description: str
  attributes: list[Attribute]
}

class Piece {
  id: str
  type: Type
  design: Design
  plane: Plane
  center: Coord
  scale: float
  mirrorPlane: Plane
  props: list[Prop]
  isHidden: bool
  isLocked: bool
  color: str
  description: str
  attributes: list[Attribute]
}

class Group {
  pieces: list[Piece]
  color: str
  name: str
  description: str
  attributes: list[Attribute]
}

class Side {
  piece: Piece
  designPiece: Piece
  port: Port
}

class Connection {
  connected: Side
  connecting: Side
  gap: float
  shift: float
  rise: float
  rotation: float
  turn: float
  tilt: float
  x: float
  y: float
  description: str
  attributes: list[Attribute]
}

class Stat {
  key: str
  unit: str
  min: float
  minExcluded: bool
  max: float
  maxExcluded: bool
}

class Design {
  name: str
  variant: str
  view: str
  pieces: list[Piece]
  connections: list[Connection]
  stats: list[Stat]
  props: list[Prop]
  layers: list[Layer]
  activeLayer: Layer
  groups: list[Group]
  canScale: bool
  canMirror: bool
  unit: str
  location: Location
  authors: list[Author]
  concepts: list[str]
  icon: str
  image: str
  description: str
  attributes: list[Attribute]
  created: datetime
  updated: datetime
}

class Representation {
  url: str
  description: str
  tags: list[str]
  attributes: list[Attribute]
  --
  context Representation inv descriptionCanBeEmpty:
    description->notEmpty() or description->isEmpty()
}

class Port {
  id: str
  description: str
  mandatory: bool
  family: str
  compatibleFamilies: list[str]
  point: Point
  direction: Vector
  t: float
  attributes: list[Attribute]
  --
  context Port inv optionalFieldsCanBeEmpty:
    description->notEmpty() or description->isEmpty() and
    family->notEmpty() or family->isEmpty()
  context Port inv tInValidRange:
    t >= 0 and t < 1
  context Port inv directionIsUnitVector:
    direction.x * direction.x + direction.y * direction.y + direction.z * direction.z = 1
  context Port inv compatibleFamiliesIncludesOwnFamily:
    family->notEmpty() implies compatibleFamilies->includes(family)
}

class Layer {
  name: str
  description: str
  color: str
}

class Group {
  name: str
  description: str
  color: str
  pieces: list[Piece]
  attributes: list[Attribute]
  --
  context Group inv nameCanBeEmpty:
    name->notEmpty() or name->isEmpty()
  context Group inv descriptionCanBeEmpty:
    description->notEmpty() or description->isEmpty()
}

class Family {
  name: str
}

class Piece {
  id: str
  description: str
  plane: Plane
  center: Coord
  scale: float
  mirrorPlane: Plane
  hidden: bool
  locked: bool
  color: str
  type: Type
  design: Design
  piece: Piece
  attributes: list[Attribute]
  --
  context Piece inv descriptionCanBeEmpty:
    description->notEmpty() or description->isEmpty()
  context Piece inv validPieceReference:
    (type->notEmpty() and design->isEmpty() and piece->isEmpty()) or
    (type->isEmpty() and design->notEmpty() and piece->notEmpty())
  context Piece inv colorValidation:
    color->isEmpty() or color.matches('^#[0-9A-Fa-f]{6}$')
  context Piece inv scalePositive:
    scale > 0
  context Piece inv noSelfReference:
    piece <> self
}

class Plane {
  origin: Point
  xAxis: Vector
  yAxis: Vector
  --
  context Plane inv axesAreOrthogonal:
    xAxis.x * yAxis.x + xAxis.y * yAxis.y + xAxis.z * yAxis.z = 0
  context Plane inv axesAreUnitVectors:
    xAxis.x * xAxis.x + xAxis.y * xAxis.y + xAxis.z * xAxis.z = 1 and
    yAxis.x * yAxis.x + yAxis.y * yAxis.y + yAxis.z * yAxis.z = 1
}

class Connection {
  connecting: Side
  connected: Side
  description: str
  gap: float
  shift: float
  rise: float
  rotation: float
  turn: float
  tilt: float
  x: float
  y: float
  attributes: list[Attribute]
  --
  context Connection inv descriptionCanBeEmpty:
    description->notEmpty() or description->isEmpty()
  context Connection inv portsAreCompatible:
    connecting.port.compatibleFamilies->includes(connected.port.family) or
    connected.port.compatibleFamilies->includes(connecting.port.family)
  context Connection inv noDuplicateConnections:
    connecting <> connected
  context Connection inv rotationInValidRange:
    rotation >= -180 and rotation <= 180
  context Connection inv turnInValidRange:
    turn >= -180 and turn <= 180
  context Connection inv tiltInValidRange:
    tilt >= -180 and tilt <= 180
}

class Side {
  piece: Piece
  port: Port
}

class Attribute {
  name: str
  value: str
  unit: str
  definition: str
  --
  context Attribute inv valueCanBeEmpty:
    value->notEmpty() or value->isEmpty()
  context Attribute inv definitionCanBeEmpty:
    definition->notEmpty() or definition->isEmpty()
  context Attribute inv emptyValueMeansTrue:
    value->isEmpty() implies value = 'true'
  context Attribute inv unitCanBeEmpty:
    unit->notEmpty() or unit->isEmpty()
}

class Author {
  name: str
  email: str
}

class Point {
  x: float
  y: float
  z: float
}

class Vector {
  x: float
  y: float
  z: float
  --
  context Vector inv notZeroVector:
    x <> 0 or y <> 0 or z <> 0
}

class Coord {
  x: float
  y: float
}

class Quality {
  key: str
  name: str
  description: str
  uri: str
  scalable: bool
  kind: QualityKind
  si: str
  imperial: str
  min: float
  minExcluded: bool
  max: float
  maxExcluded: bool
  default: float
  formula: str
  benchmarks: list[Benchmark]
  attributes: list[Attribute]
  --
  context Quality inv optionalFieldsCanBeEmpty:
    description->notEmpty() or description->isEmpty() and
    uri->notEmpty() or uri->isEmpty() and
    si->notEmpty() or si->isEmpty() and
    imperial->notEmpty() or imperial->isEmpty() and
    formula->notEmpty() or formula->isEmpty()
  context Quality inv defaultValueInRange:
    (min->notEmpty() implies default >= min) and
    (max->notEmpty() implies default <= max)
  context Quality inv minLessThanMax:
    min->notEmpty() and max->notEmpty() implies min < max
}

class QualityKind {
  <<enumeration>>
  General
  Design
  Type
  Piece
  Connection
  Port
}

class Benchmark {
  name: str
  icon: str
  min: float
  minExcluded: bool
  max: float
  maxExcluded: bool
  --
  context Benchmark inv iconCanBeEmpty:
    icon->notEmpty() or icon->isEmpty()
  context Benchmark inv minLessThanMax:
    min < max
}

class Prop {
  key: str
  value: str
  unit: str
  attributes: list[Attribute]
  --
  context Prop inv unitCanBeEmpty:
    unit->notEmpty() or unit->isEmpty()
}

class Stat {
  key: str
  unit: str
  min: float
  minExcluded: bool
  max: float
  maxExcluded: bool
  --
  context Stat inv unitCanBeEmpty:
    unit->notEmpty() or unit->isEmpty()
  context Stat inv minLessThanMax:
    min < max
}



Design *-- "0..*" Piece : contains >
Design *-- "0..*" Connection : contains >
Design *-- "0..*" Layer : has >
Design *-- "0..*" Group : has >
Design *-- "0..*" Attribute : has >
Design *-- "0..*" Stat : measures >

Type *-- "0..*" Representation : has >
Type *-- "0..*" Port : has >
Type *-- "0..*" Attribute : has >

Piece *-- "1" Type : instance of >
Piece o-- "0..1" Plane : located by >
Piece o-- "0..1" Plane : mirrored by >
Piece *-- "0..*" Attribute : has >
Piece o-- "0..1" Coord : has center >

Group *-- "0..*" Piece : contains >

Connection *-- "0..*" Attribute : has >
Connection o-- "1" Side : connected >
Connection o-- "1" Side : connecting >

Side o-- "1" Piece : refers to >
Side o-- "1" Port : refers to >

Representation *-- "0..*" Attribute : has >

Port *-- "0..*" Attribute : has >
Port *-- "1" Point : at >
Port *-- "1" Vector : oriented by >
Port *-- "1" Family : has >
Port *-- "0..*" Family : compatible with >
Port *-- "0..*" Prop : has >

Plane *-- "1" Point : origin >
Plane *-- "1" Vector : xAxis >
Plane *-- "1" Vector : yAxis >

Quality *-- "0..*" Benchmark : has >
Quality *-- "0..*" Attribute : has >
Quality *-- "1" QualityKind : classified by >

Prop o-- "1" Quality : references >
Prop *-- "0..*" Attribute : has >

Stat o-- "1" Quality : references >

@enduml